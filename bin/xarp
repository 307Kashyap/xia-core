#!/usr/bin/python
#ts=4
#
# Copyright 2011 Carnegie Mellon University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
import os
import re
import sys
import getopt
import argparse
import telnetlib
import subprocess

APP_VERSION="1.0"

# default Click host and port (can be changed on cmd line)
HOST="localhost"
PORT=7777

# Minimum Click version required
MAJOR=1
MINOR=3

# ARP table format string
FORMAT="%-42s %-18s %-8s %s\n"

#
# contains the configuration information
# retrieved from click
# data here is aquired by parsing the result of the flatconfig click command
# currently we don't do a lot with it
#
class RouterConfig:
	"""router configuration"""

	def __init__(self, conf):
		self._hostname = os.uname()[1]
		self._cards = {}

		# get click port #'s indexed by iface name
		rx = re.compile("FromDevice\((\w+)\).*\[(\w+)\]")
		lines = conf.strip().split('\n')
		for line in lines:
			fields = rx.match(line)
			if fields != None:
				self._cards[fields.group(1)] = fields.group(2)

	#
	# getter methods
	#
	def card(self, iface):
		return self._cards[iface]

	def hostname(self):
		return self._hostname


#
# The main body of the xarp app
#
class XArpApp:
	connected = False
	csock = None

	#
	# the main logic of the xroute app
	#
	def run(self):
		parser = argparse.ArgumentParser(description = 'XIA ARP %s' % APP_VERSION,
			epilog='Note: add, clear, and delete are mutually exclusive')
		parser.add_argument("-p", "--print", action='store_true', dest='print_it', help='print the ARP table (default action)')
		parser.add_argument("-c", "--clear", action="store_true", help='purge all entries in the ARP tables')
		parser.add_argument("-a", "--add", nargs=4, help='Add an ARP table entry', metavar=('iface','hid','mac','static'))
		parser.add_argument("-d", "--delete", nargs=2, help='Delete an ARP table entry', metavar=('iface', 'hid'))
		args = parser.parse_args()

		if args.clear == False and args.add == None and args.delete == None:
			# always print if not options are given
			args.print_it = True

		# connect to click and parse the click configuration into our config object
		self.connectToClick()
		self.config = RouterConfig(self.readData("config"))

		if args.add != None:
			# add an entry to the ARP table
			self.addEntry(args.add)
		elif args.delete != None:
			# delete the specified ARP entry
			self.deleteEntry(args.delete)
		elif args.clear == True:
			# clear the ARP table
			self.purge()

		if args.print_it:
			# print the ARP tables to stdout
			print(self.getArpTable(self.config.hostname()))

		self.shutdown()

	#
	# print an error message and exit the app with an error
	#
	def errorExit(self, msg):
		print msg
		self.shutdown()
		sys.exit(-1)

	#
	# get the ciick statuscode and message
	# some operations get 2 lines of status message with the code on each
	# and the second line is more useful, so the caller can specify if we should
	# die on error, or keep going and loop back for the 2nd line
	#
	def checkStatus(self, die):
		rc = self.csock.read_until("\n")
		rc = rc.strip()

		# some result code lines are in the form of 'nnn msg' and some are nnn-msg'
		# so ignore the odd character by slicing round it
		code = int(rc[:3])
		msg = rc[4:-1]
		if (die and code != 200):
			self.errorExit("error %d: %s" % (code, msg))
		return code

	#
	# read the length of data sent by click so we can consume the right
	# amout of text
	#
	def readLength(self):
		text = self.csock.read_until("\n")
		text.strip()
		(data, length) = text.split()
		if data != "DATA":
			self.errorExit(tn, "error retreiving data length")
		return int(length)

	#
	# connect to the click control socket
	#
	def connectToClick(self):
		try:
			self.csock = telnetlib.Telnet(HOST, PORT)
			self.connected = True

			data = self.csock.read_until("\n")
		except:
			self.errorExit("Unable to connect to Click")

		# make sure it's really click we're talking to
		data = data.strip()
		[name, ver] = data.split("/")
		[major, minor] = ver.split(".")
		if name != "Click::ControlSocket":
			self.errorExit("Socket is not a click ControlSocket")
		if int(major) < MAJOR or (int(major) == MAJOR and int(minor) < MINOR):
			self.errorExit("Click version %d.%d or higher is required" % (MAJOR, MINOR))

	#
	# send a read command to click and return the resulting text
	#
	def readData(self, cmd):
		self.csock.write("READ %s\n" % (cmd))
		self.checkStatus(True)

		length = self.readLength()
		buf=""
		while len(buf) < length:
			buf += self.csock.read_some()
		return buf

	#
	# send a write command to click and verify it worked OK
	#
	def writeData(self, cmd):
		self.csock.write("WRITE %s\n" % (cmd))
		code = self.checkStatus(False)

		# the click write handler returns 2 lines of status on an error, and the
		#second line contains a more useful message, so call it again
		if code != 200:
			self.checkStatus(True)

	#
	# print the ARP table to stdout
	#
	def printTable(self, card, iface):
		tfmt = "%s/xlc%s/xarpq.table"
		cmd = tfmt % (self.config.hostname(), card)
		data = self.readData(cmd)
		text = ""

		lines = data.lower().split("\n")
		for l in lines:
			line = re.sub('-', ':', l)
			if line != "":
				(hid, mac, age, perm) = line.split(' ')

				if perm == '0':
					a = "%.2f" % float(age)
				else:
					a = ""
				text += FORMAT % (hid[4:], mac, iface, a)
		return text


	#
	# format the route table header and loop through the requested XID tables
	#
	def getArpTable(self, device):
		text  = FORMAT % ("HID", "HW ADDRESS", "IFACE", "AGE (s)")
		text +=  "-" * 78
		text += "\n"

		for (iface, card) in self.config._cards.iteritems():
			text += self.printTable(card, iface)

		return text

	#
	# send an individual delete route command to click
	#
	# only minor error checking is done here, click will do the rest of it
	#
	def deleteEntry(self, args):
		iface = args[0]
		hid = args[1]

		if (iface == None or iface == ""):
			self.errorExit("Interface not specified")
		if (hid == None or hid == ""):
			self.errorExit("HID not specified")

		cmd = "%s/xlc%s/xarpq.delete %s" % (self.config.hostname(), self.config.card(iface), hid.upper())
		print cmd
		self.writeData(cmd)
		print "deleted arp entry for %s" % (hid)


	#
	# Add an ARP table entry
	#
	# only minor error checking is done here, click will do the rest of it
	#
	def addEntry(self, args):
		iface = args[0]
		hid = args[1]
		mac = args[2]
		static = args[3]	# if true, table entry won't expire

		print iface, hid, mac, static

		if self.config.card(iface) == None:
			self.errorExit("%s is not a valid XIA interface" % iface)
		if (hid == None or hid == ""):
			self.errorExit("HID not specified")
		if (mac == None or mac == ""):
			self.errorExit("mac not specified")

		cmd = "%s/xlc%s/xarpq.insert %s %s %s" % (self.config.hostname(), self.config.card(iface), hid.upper(), mac, static)

		self.writeData(cmd)
		print "added arp entry for %s: HID %s ETH %s" % (iface, hid, mac)

	#
	# purge all entries in the table
	#
	def purge(self):
		for (iface, card) in self.config._cards.iteritems():
			cmd = "%s/xlc%s/xarpq.clear" % (self.config.hostname(), card)
			self.writeData(cmd)

	#
	# close the connection to click
	#
	def shutdown(self):
		if (self.connected):
			self.csock.write("quit\n")


#
# let's do this thing
#
def main():
	xarp = XArpApp()
	xarp.run()

if __name__ == "__main__":
	main()
