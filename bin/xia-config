#!/usr/bin/env python
#
# Copyright 2017 Carnegie Mellon University
#
# Licensed under the Apache License, Version 2.0 (the 'License');
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an 'AS IS' BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# FIXME: 
# - this is calling the python program xconfig.py to make conf files
#   seems better to merge them together
# - can we make click always just use xia.click?
# - how can we disable key generation messages?

import os
import re
import sys
import argparse
import ipaddress
import subprocess
from glob import glob

import genkeys
import xconfig
import nodeconf
import keymanage
import xiapyutils

VER = '%(prog)s 1.0'

hostname = xiapyutils.getxiaclickhostname()

# list of files and locations to delete when clean is run ####################
conf_files = [
    'etc/xia.ini',
    'etc/click/host*.click',
    'etc/click/router*.click',
    'etc/*.conf',
    'etc/hosts.xia',
    'etc/RHID.cred',
    'key/*',
    'ca/*',
    'publishers/*'
        ]

temp_files = [
    'cachefilter-click.sock',
    'xcache*',
    'content/*'
        ]


#
# config validators ##########################################################
#

#
# validate and separate the waveserver parameters
#
def waveserver(arg):

    try:
        [m, addr] = arg.split(',')
        [i, p] = addr.split(':')
    except ValueError:
        raise argparse.ArgumentTypeError('invalid waveserver options should be: mac,ip:port')

    # is it a valid IP address?
    try:
        ipaddress.ip_address(unicode(i, 'utf-8'))
    except ipaddress.AddressValueError as err:
        raise argparse.ArgumentTypeError(str(err))

    # make sure the port is an int
    try:
        int(p)
    except ValueError as err:
        raise argparse.ArgumentTypeError(str(err))

    # make sure the mac address is correctly formatted
    if re.match('[0-9a-f]{2}([-:])[0-9a-f]{2}(\\1[0-9a-f]{2}){4}$', m.lower()) == None:
        raise argparse.ArgumentTypeError('invalid MAC address: {}'.format(m))

    return {'mac':m, 'addr':i, 'port':p}


#
# make sure the specified interface exists on this machine
#
def iface(arg):
    if not arg in os.listdir('/sys/class/net'):
        raise argparse.ArgumentTypeError('invalid interface name: {}'.format(arg))
    return arg


#
# validate 4ID configuration info
#
def four_id(arg):
    # FIXME: implement once/if 4IDs are working again
    #  -4 generate and use a dual stack click script
    #  -m manually set the node's 4ID IP address

    print '4IDs are not currently supported'
    sys.exit(1)


#
# ensure socket config is correct
#
def socket_server(arg):
    #  -P set the TCP socket ports to use (instead of ToDevice/FromDevice)

    print 'socket configurations are not currently supported'
    sys.exit(1)



# helpers ####################################################################
#
# display status unless we are in stealth mode
#
def status(msg, *params):
    if not args.quiet:
        if params:
            print msg, params
        else:
            print msg

#
# are we already configured?
#
def configured(args):
    return node.nodetype() != None



#
# create xia system directories with correct permissions
#
def make_dir_with_permissions(dir, perm):

    path = '%s/%s' % (xiapyutils.xia_srcdir(), dir)
    try:
        old_umask = os.umask(0)
        os.makedirs(path, perm)
    except OSError:
        # don't error if the directory already exists
        None

    finally:
        os.umask(old_umask)


#
# translate our config into to something usable by xconfig
#
# FIXME: This is a hack until there's time to integrate more cleanly with xconfig.
#
def run_xconfig(args):
    if args.nodetype == 'host':
        cmdline = '-t'
    elif args.nodetype == 'controller':
        cmdline = '-r'
    else:
        cmdline = '-r'

    cmdline += ' -i ' + hostname

    # get ignored interfaces
    comma = False
    if args.ignore:
        cmdline += ' -f '
        for i in args.ignore:
            if comma:
                cmdline += ','
            cmdline += i
            comma = True

    # node should have up to 8 interfaces instead of 4
    if args.ports == '8':
        cmdline += ' -8'

    # we'll proxy through a waveserver
    if args.waveserver:
        cmdline += ' -W %s,%s:%s' %(args.waveserver['mac'], args.waveserver['addr'], args.waveserver['port'])
    
    cmds = cmdline.split(' ')
    # now make the configuration
    xconfig.verbose = False

    if args.nodetype == 'host':
        status('creating host.click')
    else:
        status('creating router.click')
    xconfig.build(cmds)


#
# create xia.ini
#
def create_nodeconf(args):
    status('creating credentials')

    node.set('hostname', hostname)
    node.set('nodetype', args.nodetype)
    node.set('numports', str(args.ports))
    node.set('hid', genkeys.create_new_HID())
    node.set('hostname', hostname)
    node.set('hostname', hostname)
    node.set('hostname', hostname)

    if args.nodetype == 'controller':
        node.set('ad', genkeys.create_new_AD())
        node.set('controller_sid', genkeys.create_new_SID())
        if args.nameserver:
            node.set('nameserver_sid', 'SID:1110000000000000000000000000000000001113')
        if args.rendezvous:
            node.set('rendezvous_sid', genkeys.create_new_SID())
            node.set('rendezvous_ctl_sid', genkeys.create_new_SID())

    if args.ignore:
        for iface in args.ignore:
            node._set('ignore', iface, 'True')

    if args.waveserver:
        node._set('waveserver', 'mac', args.waveserver['mac'])
        node._set('waveserver', 'addr', args.waveserver['addr'])
        node._set('waveserver', 'port', args.waveserver['port'])
    
    status('creating xia.ini')
    node.write()

#
# configuration for all node types
#
def common_config(args):

    # don't overwrite existing configurations

    if configured(args):
        print 'XIA is already configured as a %s' % node.nodetype()
        sys.exit(0)

    status('Generating %s config files' % args.nodetype)

    node.reset()
    create_nodeconf(args)
    run_xconfig(args)

    make_dir_with_permissions('ca', 0775)
    make_dir_with_permissions('key', 0775)
    make_dir_with_permissions('publishers', 0775)


#
# make the resolv.conf file
#
def create_resolv_conf_file():
    status('creating resolv.conf')
    with open (os.path.join(xiapyutils.xia_etcdir(), 'resolv.conf'), 'w') as resolvconf:
        ad = node.ad()
        hid = node.hid()
        ns_sid = node.nameserver_sid()
        rv_sid = node.rendezvous_sid()
        rvc_sid = node.rendezvous_ctl_sid()

        if ns_sid:
            resolvconf.write('nameserver=RE %s %s %s\n' % (node.ad(), node.hid(), ns_sid))
        
        if rv_sid and rvc_sid:
            rv_fallback = '%s %s %s' % (ad, hid, rv_sid)
            rvc_dag = 'RE %s %s %s' % (ad, hid, rvc_sid)
            router_rv_dag = 'RE %s ( %s ) %s' % (ad, rv_fallback, hid)
            resolvconf.write('rendezvous=%s\n' % (router_rv_dag))
            resolvconf.write('rendezvousc=%s\n' % (rvc_dag))


#
# create the RHID.cred file that routers use to join the AD
#
def create_rhid_cred_file():
    status('creating RHID.cred')
    params  = [os.path.join(xiapyutils.xia_srcdir(), 'daemons/xnetjd/credmgr.py'), '-r']
    subprocess.check_call(params)


#
# create the controller.conf file that is added to trusted.conf on peer controllers so that we can talk to them
#
def create_controller_conf_file():
    status('creating controller.conf')
    with open (os.path.join(xiapyutils.xia_etcdir(), 'controller.conf'), 'w') as f:
        f.write('# controller.conf\n')
        f.write('# Copy or append this file to the trusted.conf file in neighbor ADs.\n')
        f.write('# The controller dag in this file will continue to be used across xia\n')
        f.write('# restarts.\n')
        f.write('[%s]\n' % node.ad())
        f.write('dag=DAG 0 - %s 1 - %s 2 - %s\n' % (node.ad(), node.hid(), node.controller_sid()))


def create_trusted_conf_file():
    with open (os.path.join(xiapyutils.xia_etcdir(), 'trusted.conf'), 'w') as trusted:
        trusted.write('# ADs that we trust and their respective controllers should be added to\n')
        trusted.write('# this file. Run \'addtopeer host\' on the other controller specifying\n')
        trusted.write('# this hostname to automatically update the file. Or, copy controller.conf\n')
        trusted.write('# from the other controller to etc/peer.tmp and then run \'addtopeer -l\' locally.\n')

        # there's already a peer file from another AD here
        # stick it into our trusted.conf
        peer = os.path.join(xiapyutils.xia_etcdir(), 'peer.tmp')
        if os.path.isfile(peer):
            cmd = [os.path.join(xiapyutils.xia_bindir(), 'addtopeer'), '-l']
            subprocess.check_call(cmd)


#
# how to finish configuring the network
#
def display_controller_footer():
    print '''
Next Steps:
 * Run the addrouter command to copy the RHID.cred file to the routers that
   will be part of this AD.

      addrouter router1 router2 10.0.0.4 ...

 * Run the addpeer command to make this AD know to neighbor ADs.
  The controller.conf file will be appended to the trusted.conf file on the
  controller of each listed AD. If this node is the nameserver, the resolf.conf
  file will be copied as well.

      addpeer controller1, 10.1.0.1 ...

Note:
 * IP connectivity is required for the above commands to function. Hostnames
 or IP addresses may be used.
 * The files will be copied to the same path location as on this machine, so make sure
   all of your routers and controllers use the same directories.
    '''


def display_router_footer():
    print '''
Next Steps:
 * On the Controller of the AD this router will be a member of:
   Run the addrouter command to install the RHID.cred file onto this router.

      addrouter routername
'''




# actions ####################################################################
#
# display configuration
#
def info(args):
    type = node.nodetype()
    if type:

        print 'Hostname:           %s' % node.hostname()
        print 'Node Type:          %s' % type
        print 'HID:                %s' % node.hid()

        if type == 'controller':
            print 'AD:                 %s' % node.ad()
            print 'Controller SID:     %s' % node.controller_sid()
            print 'Name Server SID:    %s' % node.nameserver_sid()
            print 'Rendezvous SID:     %s' % node.rendezvous_sid()
            print 'Rendezvous ctl SID: %s' % node.rendezvous_ctl_sid()

        print 'Number of ports:    %s' % node.numports()

        ifaces = node.interfaces()
        for iface in ifaces:
            print 'ignore interface:   %s' % iface

        w = node.waveserver()
        if w:
            print 'Waveserver MAC:     %s' % w[0]
            print 'Waveserver Addr:    %s:%s' % (w[1], w[2])
    else:
        print 'No configuration found'


#
# delete all config files, cached content, and any temp files
#
def clean(args):
    try:
        for files in temp_files:
            for f in glob(os.path.join('/tmp', files)):
                status('removing {}'.format(f))
                os.remove(f)

        for files in conf_files:
            files = os.path.join(xiapyutils.xia_srcdir(), files)

            for f in glob(files):
                status('removing {}'.format(f))
                os.remove(f)

    except IOError as e:
        if (e[0] == errno.EPERM):
            print 'root permission required'
        sys.exit(1)



#
# make the node an endhost
#
def host(args):
    args.nodetype = 'host'
    common_config(args)


#
# make the node a router
#
def router(args):
    args.nodetype = 'router'
    common_config(args)
    display_router_footer()


#
# make the node a controller
#
def controller(args):
    args.nodetype = 'controller'
    common_config(args)
    create_rhid_cred_file()

    create_controller_conf_file()

    if node.nameserver_sid() or node.rendezvous_sid():
        create_resolv_conf_file()

    create_trusted_conf_file()
    display_controller_footer()


#
# let's go!
#

node = nodeconf.nodeconf()
node.read()

parser = argparse.ArgumentParser(description='configure an XIA node')
parser.add_argument('-v', '--version', action='version', version=VER)
parser.add_argument('-q', '--quiet', action='store_true', help='hide status messages')

sub = parser.add_subparsers(help='add -h following arguments for additional options')

# these arguments are common to the host, router, and controller configurations
common_parser = argparse.ArgumentParser(add_help=False)
common_parser.add_argument('-i', '--ignore', nargs='+', type=iface, metavar='iface', help='ignore interface')
common_parser.add_argument('-p', '--ports', choices=['4','8'], default=4, help='# of interfaces (default=4)')
common_parser.add_argument('-w', '--waveserver', type=waveserver, metavar='DSRC_MAC,ARADA_IP:PORT', help='connect via a waveserver')

# FIXME: add support for these at some point
#common_parser.add_argument('-s', '--socket', type=socket_server, metavar='port', help='use a TCP socket instead of an ethernet interface')
#`common_parser.add_argument('--4id', type=four_id, help='configure an interface as 4ID')

info_parser = sub.add_parser('info', help='display current configuration')
info_parser.set_defaults(func=info)

clean_parser = sub.add_parser('clean', help='delete configuration and generated files')
clean_parser.set_defaults(func=clean)

host_parser = sub.add_parser('host', parents=[common_parser], help='configure as an XIA host')
host_parser.set_defaults(func=host)

router_parser = sub.add_parser('router', parents=[common_parser], help='configure as an XIA router')
router_parser.set_defaults(func=router)

controller_parser = sub.add_parser('controller', parents=[common_parser], help='configure as an XIA controller')
controller_parser.add_argument('-n', '--nameserver',action='store_true', help='run the nameserver on this node')
controller_parser.add_argument('-r', '--rendezvous',action='store_true', help='run a rendezvous server on this node')
controller_parser.set_defaults(func=controller)

# annoying work around to get a default subparser
if (len(sys.argv) < 2):
        args = parser.parse_args(['--help'])
else:
    args = parser.parse_args()
args.func(args)

