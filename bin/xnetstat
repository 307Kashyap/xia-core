#!/usr/bin/python
#ts=4
#
# Copyright 2015 Carnegie Mellon University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
import os
import sys
import getopt
import datetime
import telnetlib

APP_VERSION="0.1"
TITLE="XIA netstat version %s"

# default Click host and port (can be changed on cmd line)
HOST="localhost"
PORT=7777

# Minimum Click version required
MAJOR=1
MINOR=3

KNOWN_TYPES = [ "STREAM", "DGRAM", "RAW", "CHUNK" ]

#
# class for managing command line configuration options
#
class Options:
	""" xnetstat configuration options"""
	def __init__(self):
		self._host = HOST
		self._port = PORT
		self._devices = []
		self._types = []

	#
	# parse the command line so we can do stuff
	#
	def getOptions(self):
		try:
			# FIXME: make the option names more meaningful
			shortopt = "hpnvif:d:a:r:"
			opts, args = getopt.getopt(sys.argv[1:], shortopt, 
				["help", "host=", "port=", "device=", "type="])
		except getopt.GetoptError, err:
			# print	 help information and exit:
			print str(err) # will print something like "option -a not recognized"
			self.help()
			sys.exit(2)

		for o, a in opts:
			if o in ("-h", "--help"):
				self.help()
			elif o in ("--host"):
				self._host = a
			elif o in ("--port"):
				self._port = a
			elif o in ("--device"):
				self._devices.append(a)
			elif o in ("--type"):
				self._types.append(a)
			else:
			 	assert False, "unhandled option"

	#
	# display helpful information
	#
	def help(self):
		print """
usage: xnetstat [-hpnvif:d:a:r:] [commands]
where:
  -h <host>        : specify the click host address
  --host=<host>

  --port=<port>    : specify the click control port

  --device=<device>: only output info for the specified device (router0)
	                 can be specified multiple times on the command line

  --type=<stype>   : only output information for the specified Socket type
                     can be specified multile times on the command line
"""
		sys.exit()

	def host(self):
		return self._host
	
	def port(self):
		return self._port

	def devices(self):
		return self._devices

	def types(self):
		return self._types

#
# contains the configuration information
# retrieved from click
# data here is aquired by parsing the result of the flatconfig click command
# currently we don't do a lot with it
#
class NetstatConfig:
	"""netstat configuration"""
	
	def __init__(self, flat):
		self._devices = []

		entries = flat.split(";")
		for entry in entries:
			entry = entry.strip()

			if entry.find("/cache ::") > 0:
				# hacky way of finding the devices that are configured
				self.addDevice(entry)
			else:
				# get other config stuff out of here at some point
				None
	#
	# found a device entry, add it to our device list if we dont' have it already
	#
	def addDevice(self, text):
		sep = text.find("/")
		dev = text[:sep]
		found = False
		for d in self._devices:
			if d == dev:
				found = True
		if found == False:
			self._devices.append(dev)

	#
	# getter methods
	#
	def devices(self):
		return self._devices

#
# The main body of the xnetstat app
# 
class XnetstatApp:
	connected = False	
	csock = None
	devices = []
	types = []
	
	#
	# the main logic of the xnetstat app
	#
	def run(self):
		# get the command line options
		self.options = Options()
		self.options.getOptions()

		# connect to click and parse the click configuration into our config object
		self.connectToClick()
		self.config = NetstatConfig(self.readData("flatconfig"))

		# if specified by the user, only get info for the specified devices (router0,...)
		if (len(self.options.devices()) > 0):
			self.devices = self.options.devices()
		else:
			self.devices = self.config.devices()

		# if specified by the user, only get info for the specified Socket types (STREAM, DGRAM,...)
		if (len(self.options.types())):
			self.types = self.options.types()
		else:
			self.types = KNOWN_TYPES

		for device in self.devices:
			print(self.getSocketTable(device))

		self.shutdown()

	#
	# print an error message and exit the app with an error
	#
	def errorExit(self, msg):
		print msg
		self.shutdown()
		sys.exit(-1)

	#
	# get the click statuscode and message
	# some operations get 2 lines of status message with the code on each
	# and the second line is more useful, so the caller can specify if we should 
	# die on error, or keep going and loop back for the 2nd line
	#
	def checkStatus(self, die):
		rc = self.csock.read_until("\n")
		rc = rc.strip()

		# some result code lines are in the form of 'nnn msg' and some are nnn-msg'
		# so ignore the odd character by slicing round it
		code = int(rc[:3])
		msg = rc[4:-1]
		if (die and code != 200):
			self.errorExit("error %d: %s" % (code, msg))
		return code

	#
	# read the length of data sent by click so we can consume the right
	# amout of text
	#
	def readLength(self):
		text = self.csock.read_until("\n")
		text.strip()
		(data, length) = text.split()
		if data != "DATA":
			self.errorExit(tn, "error retreiving data length")
		return int(length)

	#
	# connect to the click control socket
	#
	def connectToClick(self):
		try:
			self.csock = telnetlib.Telnet(self.options.host(), self.options.port())
			self.connected = True

			data = self.csock.read_until("\n")
		except:
			self.errorExit("Unable to connect to Click")

		# make sure it's really click we're talking to
		data = data.strip()
		[name, ver] = data.split("/")
		[major, minor] = ver.split(".")
		if name != "Click::ControlSocket":
			self.errorExit("Socket is not a click ControlSocket")
		if int(major) < MAJOR or (int(major) == MAJOR and int(minor) < MINOR):
			self.errorExit("Click version %d.%d or higher is required" % (MAJOR, MINOR))

	#
	# send a read command to click and return the resulting text
	#
	def readData(self, cmd):
		self.csock.write("READ %s\n" % (cmd))
		self.checkStatus(True)

		length = self.readLength()
		buf=""
		while len(buf) < length:
			buf += self.csock.read_some()
		return buf

	#
	# send a write command to click and verify it worked OK
	#
	def writeData(self, cmd):
		self.csock.write("WRITE %s\n" % (cmd))
		code = self.checkStatus(False)

		# the click write handler returns 2 lines of status on an error, and the
		#second line contains a more useful message, so call it again
		if code != 200:
			self.checkStatus(True)

	#
	# print the specified socket table to stdout
	#
	def printSocketTable(self, device):
		tfmt = "%s/xrc/xtransport.netstat"
		data = self.readData(tfmt % (device))

		text =""
		sockets = data.split("\n")
		for socket in sockets:
			text += socket + "\n"
		return text


	def printTableOld(self, device, table):
		tfmt = "%s/xrc/xtransport.netstat"
		data = self.readData(tfmt % (device, table))

		text = ""
		routes = data.split("\n")
		for route in routes:
			parts = route.split(",")

			if len(parts) != 4:
				if len(parts) > 1:
					print "invalid route line: %d %s\n" % (len(parts), route)
				continue	
			xid = parts[0]
			port = parts[1]
			nexthop = parts[2]
			flags = int(parts[3])

			if port != -1:
				if xid == "-":
					xid = "(default)"
				elif self.options.verbose() == False:
					xid = self.config.getAlias(xid)

				if self.options.verbose() == False:
					nexthop = self.config.getAlias(nexthop)

				text += "%-5s %-45s %2s%-11s %08x %s\n" % (table, xid, 
						port, self.portType(port), flags, nexthop) 


#		print "text = %s" % (text)

		return text

	#
	# format the route table header and loop through the requested XID tables
	#
	def getSocketTable(self, device):
		text  = device
		text += "\n"
		text += "%-5s  %-6s  %-10s  %s\n" % ("PORT", "TYPE", "STATE",  "XID")
		text +=  "=" * 72
		text += "\n"
		text += self.printSocketTable(device)
		return text

	#
	# close the connection to click
	#
	def shutdown(self):
		if (self.connected):
			self.csock.write("quit\n")


#
# let's do this thing
#
def main():
	print TITLE % (APP_VERSION)

	xnetstat = XnetstatApp()
	xnetstat.run()

if __name__ == "__main__":
    main()
