#!/usr/bin/python

import sys
import time
import random
import requests
import argparse
import datetime
import xiapyutils
from mpegdash.parser import MPEGDASHParser
from multiprocessing import Process

VER = '1.0'
MANIFEST='http://www.origin.xia/%s.mpd'
WINDOW_SIZE=4
UPPER_THRESHOLD=0.75
LOWER_THRESHOLD=0.5

class DashVideo:
    class InvalidBitrate(Exception):
        '''Raise when the requested bitrate doesn't exist'''

    class TransferFailed(Exception):
        '''Raise when unable to fetch the segment'''


    def __init__(self, name, id, logging):
        self.manifest = MANIFEST % name
        self.id = id
        self.logging = logging
        self.transfer_time = []
        self.encodings = {}
        self.next_segment = 0
        self.num_segments = 0
        self.elapsed = 0
        self.duration = 0
        self.segment_length = 0
        self.session =  None
        self.loaded = False

        if logging:
            fname = 'dashclient-%d.log' % id
            self.logfile = open(fname, 'a')
            self.log('starting %s' % name)

        self.get_manifest()
        self.log('num segments: %d' % self.num_segments)
        self.current_bitrate = sorted(self.encodings.keys())[0]


    def __len__(self):
        return self.num_segments


    def __iter__(self):
        return self


    def __del__(self):
        if self.logging:
            self.log('closing %s' % self.manifest)
            self.logfile.close()


    def log(self, msg):
        if self.logging:
            now = datetime.datetime.now().strftime("%b %d %H:%M:%S.%f")
            self.logfile.write('%s %s\n' % (now, msg))



    def adjust_bitrate(self, elapsed):
        self.transfer_time.append(elapsed)

        # only adjust if user didn't set a bit rate or if we have
        #  enough segments to get a good average
        if args.bitrate == 0 and len(self.transfer_time) >= WINDOW_SIZE:
            avg = 0.0
            for t in self.transfer_time[-WINDOW_SIZE:]:
                avg += t

            avg /= WINDOW_SIZE
            i = self.bitrates().index(self.current_bitrate)

            if avg > self.segment_length * UPPER_THRESHOLD:
                # segments are too large for the current bitrade, reduce it if possible
                if i > 0:
                    self.set_bitrate(self.bitrates()[i - 1])

            elif avg < self.segment_length * LOWER_THRESHOLD:
                # we have the bandwidth to use higher quality video
                if i < len(self.encodings) - 1:
                    self.set_bitrate(self.bitrates()[i + 1])


    def next(self):
        if (not self.loaded) or self.next_segment >= self.num_segments:
            raise StopIteration
        else:
            url = '%s&client=%s' % (self.encodings[self.current_bitrate][self.next_segment], self.id)
            self.log('fetching %s' % url)
            self.next_segment += 1
            print self.id, url, ' -> ',
            try:
                start = datetime.datetime.now()
                req = self.session.get(url)
                now = datetime.datetime.now()
                elapsed = now - start

                if req.status_code != 200:
                    raise DashVideo.TransferFailed(req.status_code)

                if self.next_segment == 2:
                    # if this were a player the video could start playing
                    self.log('joined %s' % self.manifest)

                msec = elapsed.seconds  * 1000.0 + float(elapsed.microseconds) / 1000.0
                sec  =  float(elapsed.seconds)  + float(elapsed.microseconds) / 1000000.0
                tput = len(req.content) * 8.0 / sec / 1000000.0
                print '{} {} {: 3.3f} sec {: 3.3f} mbps'.format(req.status_code, self.current_bitrate, sec, tput)
                self.log('{} bytes {: 3.3f} sec {: 3.3f} mbps'.format(len(req.content), sec, tput))

                self.adjust_bitrate(msec)

                return (url, req.content)

            except Exception as e:
                print str(e)
                return ('', None)


    def set_bitrate(self, rate):
        if rate == 0:
            self.current_bitrate = self.bitrates()[len(self.bitrates()) / 2]

        elif rate in self.encodings.keys():
            self.current_bitrate = rate
        else:
            raise DashVideo.InvalidBitrate('This video is not available at %s bps' % rate)

        self.log('setting bitrate to %d' % self.current_bitrate)
        return rate


    def bitrates(self):
        return sorted(self.encodings.keys())


    def bitrate(self):
        return self.current_bitrate


    def rewind(self):
        self.log('rewinding %s' % self.manifest)
        self.next_segment = 0


    def info(self):
        print 'manifest:       ', self.manifest
        print 'duration:       ', self.duration, 'ms'
        print 'segment length: ', self.segment_length, 'ms'
        print 'num segments:   ', len(self)
        print 'bitrates:       ', self.bitrates()
        print 'current bitrate:', self.current_bitrate




    def get_manifest(self):
        self.log('fetching manifest: %s' % self.manifest)
        self.session = requests.Session()
        self.session.proxies = {"http": "localhost:8080"}

        try:
            req = self.session.get(self.manifest)
            m = req.text
        except Exception as e:
            print 'failed getting manifest:', str(e)
            return

        mpd = MPEGDASHParser.parse(m)
        self.loaded = True

        for period in mpd.periods:
            for adapt_set in period.adaptation_sets:
                for representation in adapt_set.representations:
                    segments = representation.segment_lists[0]

                    self.segment_length = segments.duration * 1000 / segments.timescale
                    self.duration = self.segment_length * len(segments.segment_urls)

                    init = segments.initializations[0]

                    urls = [init.source_url]

                    for segment in segments.segment_urls:
                        urls.append(segment.media)

                    self.num_segments = len(urls)
                    self.encodings[representation.bandwidth] = urls



def config():
    """parse the command line arguements and set up logging"""

    global args

    parser = argparse.ArgumentParser(description='Simple XIA DASH Client')
    parser.add_argument('videos', nargs='+', metavar='video', help='list of videos to fetch')

    parser.add_argument('-v', '--version', action='version', version=VER)
    parser.add_argument('-d', '--delay', type=float, default=1, help='inter-video delay (defalut=1000ms)')

    parser.add_argument('-l', '--log', action='store_true', help='log actions to video_name.date.log')
    parser.add_argument('-b', '--bitrate', type=int, default=0, help='bitrate to use in bps (default=adaptive')
    parser.add_argument('-s', '--segments', type=int, default=0, help='maximum # of segments to fetch')
    parser.add_argument('-r', '--randomize', action='store_true',  help='fetch a random # of segments up to specified amount')
    parser.add_argument('-t', '--threads', type = int, default=1, help='spawn n simulatane3ous client threads')

    loop_parser = parser.add_mutually_exclusive_group(required=False)
    loop_parser.add_argument('-c', '--continuous', action='store_true', help='keep looping through videos forever')
    loop_parser.add_argument('-p', '--passes', type=int, default=0, help='# of times to loop through the videos')

    args = parser.parse_args()




def get_video(name, id):
    print '\n%d fetching:       %s' % (id,  name)
    if args.segments <= 0:
        count = 1000000
    else:
        count = args.segments

    video = DashVideo(name, id, args.log)
    video.set_bitrate(args.bitrate)
    video.info()

    if len(video) < count:
        count = len(video)
    if args.randomize:
        # we don't want the entire video just some small part of it
        count = random.randint(1, count)

    for url in video:
        # the video iterator fetches the next segment from the cdn
        # since we aren't playing the content, it just gets thrown away
        count -= 1
        if count <= 0:
            break

    print '%d closing:        %s' % (id, name)



def run_client(id):

    if id > 0:
        # pause briefly so that we don't (0-5 seconds)
        time.sleep(random.random() * 5.0)

    try:
        loop = True
        while loop:
            video = random.choice(args.videos)
            get_video(video, id)
            time.sleep(args.delay)

            if args.passes > 0:
                args.passes -= 1

            if args.continuous == False and args.passes == 0:
                loop = False
    except KeyboardInterrupt:
        pass



if __name__ == '__main__':

    clients = []

    random.seed()
    config()

    for i in range(0, args.threads):
        c = Process(target=run_client, args=(i,))
        c.start()

