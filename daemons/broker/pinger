#! /usr/bin/env python
# Copyright 2018 Carnegie Mellon University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# TODO:
# better error handling
# take out fake score generation

import re
import os
import sys
import time
import socket
import struct
import random
import logging
import logging.handlers
import argparse
import subprocess
from configparser import ConfigParser

import cdn_pb2

# find the xia directory so we can load utilities
srcdir = os.getcwd()[:os.getcwd().rindex('xia-core')+len('xia-core')]
sys.path.append(os.path.join(srcdir, "bin"))
import xiapyutils

VER='1.0'
FREQ=60
DELAY=0.3
COUNT=5
BROKER='localhost'
PORT=44444
CONF='etc/scenario.conf'
CONFPATH=os.path.join(xiapyutils.xia_srcdir(), CONF)
hostname=xiapyutils.getxiaclickhostname()

#
# ping the specified dag and return average round trip time and % packet loss
#
def ping(dag):
    rtt = None
    loss = 100

    params = [os.path.join(xiapyutils.xia_srcdir(), 'bin/xping'),
            '-q', '-c', str(args.count), '-i', str(args.delay), dag]

    p = subprocess.Popen(params, stdout = subprocess.PIPE)
    lines, err = p.communicate()

    for line in lines.splitlines():
        l = re.search(r'(\d+)\% packet loss', line)
        if l:
            loss = l.group(1)
        r = re.search(r'\d+/(\d+)/\d+', line)
        if r:
           rtt = r.group(1)

    return (rtt, loss)


def update_stats():
    scores = []

    cdns = config.items('cdns')
    for (cdn, foo)  in cdns:
        logging.info('pinging clusters in %s' % cdn)
        for (cluster, value) in config.items(cdn):

            # we only want bare keys
            if value != None and value != '':
                continue

            logging.info('    %s' % cluster)

            address = config.get(cluster, 'address')
            if args.debug:
                rtt = random.randrange(0, 200)
                loss = random.randrange(0, 100, 5)
            else:
                rtt, loss = ping(address)

            if rtt == None:
                rtt = 0
            logging.info('        rtt:%s loss:%s%%' % (rtt, loss))

            score = [cluster, rtt, loss]
            scores.append(score)
    send_scores(scores)


#
# build the scores protobuf
#
def scores_msg(scores):
    msg = cdn_pb2.CDNMsg()
    msg.version = cdn_pb2.CDN_PROTO_VERSION
    msg.type = cdn_pb2.PING_SCORES_MSG

    msg.client = hostname

    for (name, rtt, loss) in scores:
        c = msg.scores.clusters.add()
        c.name = name
        c.rtt = rtt
        c.loss = loss

    return msg


#
# send the scores to the broker
#
def send_scores(scores):
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.connect((args.broker, args.port))

    msg = scores_msg(scores)
    msgstr = msg.SerializeToString()
    length = len(msgstr)

    sock.send(struct.pack("!L", length))

    sent = 0
    while sent < length:
        sent += sock.send(msgstr[sent:])

    sock.close()



#
# get the # of pings to send to each cluster
#
def count_val(arg):
    try:
        value = int(arg)
    except ValueError as err:
        raise argparse.ArgumentTypeError(str(err))

    if value < 1 or value > 10:
        message='count must be between 1 and 10'
        raise argparse.ArgumentTypeError(message)

    return value


#
# inter-ping delay validator
#
def delay_val(arg):
    try:
        value=float(arg)
    except ValueError as err:
        raise argparse.ArgumentTypeError(str(err))

    if value < 0.1 or value > 2.0:
        message='ping x delay must be between 0.1 and 2.0 seconds'
        raise argparse.ArgumentTypeError(message)

    return value


#
# test frequency validator
#
def freq_val(arg):
    try:
        value=int(arg)
    except ValueError as err:
        raise argparse.ArgumentTypeError(str(err))

    if value < 1 or value > 600:
        message='ping delay must be between 1 and 600 seconds'
        raise argparse.ArgumentTypeError(message)

    return value


#
# port # validator
#
def port_number(arg):
    try:
        port=int(arg)
    except ValueError as err:
        raise argparse.ArgumentTypeError(str(err))

    if port < 1024 or port > 65535:
        message='port # mustbe an integer between 1024 and 65535'
        raise argparse.ArgumentTypeError(message)

    return port




#
# initialize logging stuff
#
def initLogging():
    xlog = logging.getLogger()
    xlog.setLevel(args.level)

    formatter = logging.Formatter('pinger: %(message)s')

    sysloghandler = logging.handlers.SysLogHandler('/dev/log')
    sysloghandler.setFormatter(formatter)
    xlog.addHandler(sysloghandler)

    if args.verbose:
        consolehandler = logging.StreamHandler()
        consolehandler.setFormatter(formatter)
        xlog.addHandler(consolehandler)


#
# custom argparse handler to choose syslog levels
#
def loglevel(arg):
    levels = {
            0 : logging.CRITICAL,   # LOG_EMERG
            1 : logging.CRITICAL,   # LOG_ALERT
            2 : logging.CRITICAL,   # LOG_CRIT
            3 : logging.ERROR,      # LOG_ERR
            4 : logging.WARNING,    # LOG_WARNING
            5 : logging.INFO,       # LOG_NOTICE
            6 : logging.INFO,       # LOG_INFO
            7 : logging.DEBUG       # LOG_DEBUG
            }
    try:
        value = int(arg)
    except ValueError as err:
       raise argparse.ArgumentTypeError(str(err))

    if value < 0 or value > 7:
        message = "Expected a value in 0..7, got {}".format(value)
        raise argparse.ArgumentTypeError(message)

    # now convert to a python logging level value
    return levels[value]


#
# set up system
#
def configure():
    global args

    parser = argparse.ArgumentParser(description='gather CDN stats')
    parser.add_argument('-V', '--version', action='version', version=VER)
    parser.add_argument('-v', '--verbose', action='store_true', help='enable console logging')
    parser.add_argument('-l', '--level', type=loglevel, help='set syslog level [0-7] (0=LOG_EMERG, 1=LOG_ALERT, 2=LOG_CRIT, 3=LOG_ERR, 4=LOG_WARNING, 5=LOG_NOTICE, 6=LOG_INFO, 7=LOG_DEBUG)')
    parser.add_argument('-F', '--frequency', type=freq_val, help='check every COUNT seconds (default: %(default)s)')
    parser.add_argument('-c', '--count',   type=count_val, help='# of pings to send (default:%(default)d)')
    parser.add_argument('-d', '--delay',   type=delay_val, help='delay between pings in seconds (default: %(default)s)')
    parser.add_argument('-f', '--file',    type=argparse.FileType('r'), help='cdn config file (default: %s)' % CONF)
    parser.add_argument('-b', '--broker', help='IP/hostname of the broker service')
    parser.add_argument('-p', '--port', type=port_number, help='broker port (default=%(default)s)')
    parser.add_argument(      '--debug', action='store_true', help='generate random scores instead of pinging')
    parser.set_defaults(frequency=FREQ, count=COUNT, delay=DELAY, file=CONFPATH, broker=BROKER, port=PORT, level=logging.ERROR)
    args = parser.parse_args()

    initLogging()


def main():
    global config

    configure()

    # load scenario configuration
    logging.info('using conf file %s' % args.file.name)
    try:
        config = ConfigParser(allow_no_value = True)
        config.readfp(args.file)
    except Exception as err:
        logging.error(str(err))
        sys.exit(-1)

    # run it
    while True:
        update_stats()
        time.sleep(args.frequency)

if __name__ == "__main__":
    main()

