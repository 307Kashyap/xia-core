#! /usr/bin/env python
# Copyright 2018 Carnegie Mellon University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import os
import sys
import time
import rpyc
import random
import logging
import logging.handlers
import msgpack
import argparse
import threading
from rpyc.utils.server import ThreadedServer

from scenario import Scenario
import vdx

VER='1.0'

# FIXME: rpyc config - will go away when switching to xsockets and protobugfs
PORT='44444'

# default scenario config file
CONF='etc/scenario.conf'

# FIXME: we get the path in order to get the module to get the path!
srcdir = os.getcwd()[:os.getcwd().rindex('xia-core')+len('xia-core')]
sys.path.append(os.path.join(srcdir, "bin"))
import xiapyutils
CONFPATH=os.path.join(xiapyutils.xia_srcdir(), CONF)



class Broker(rpyc.Service):
    #
    # collect ping stats from client machines
    # stats include ping latency and packet loss info from the client to each cluster
    #
    def exposed_update_client_stats(self, stats):
        data = msgpack.unpackb(stats)
        logging.info('handling client update from %s' % data['name'])

        id = int(data['id'])

        # find or create new client_location entry
        client = scenario.scenario['client_locations'][id]
        if client == None:
            client = make_client_record(stats['name'], stats['id'], stats['lat'], stats['lon'])
            scenario.scenario['client_locations'][id] = client

        # reset score  list
        client['cluster_scores'] = []

        for cluster, info  in data['clusters'].iteritems():
            cluster_id = scenario.getID(cluster)
            logging.debug('cluster %s (%d) has %s %s' % (cluster, cluster_id, info['latency'], info['loss']))

            # first pass at making score score = (latency * 1000) + (packet loss percentage * 100)
            # lower is better
            score = info['latency']
            loss = info['loss']

            if score == None or score < 0 or loss == 100:
                score = 10000000000
            else:
                score *= 1000
                score += (loss * 100)
            client['cluster_scores'].append([cluster_id, score])

        logging.debug(scenario.scenario['client_locations'])


    #
    # get cache DAG from cdn hosts
    #
    def exposed_add_cdn_cluster(self, name, dag):
        logging.debug('adding dag to %s (%s)', name, dag)
        id = scenario.getID(name)
        scenario.scenario['cdn_locations'][id]['dag'] = dag
        logging.debug(scenario.scenario['cdn_locations'][id])

    def exposed_get_cdn(self, name, bitrate):
        logging.debug("handling request from %s for %s at %d" % (name, item, bitrate))
        id = scenario.getID(client)
        req = scenario['client_locations'][id]

        req['bitrate'] = bitrate
        scenario['requests'] = [req]
        # run the algorithm
        # return something


    def exposed_get_cdn(self, client, cid, bitrate):
        id = scenario.getID(client)

        logging.debug('computing optimal cluster to deliver %s to %s' % (cid, client))

        clusters = scenario.scenario['cids'][cid]

        if clusters == None:
            return ''

        # just randomize for now
        index = random.randint(0, len(clusters) - 1)
        cluster_id = clusters[index]
        dag = scenario.scenario['cdn_locations'][cluster_id]['dag']
        print dag
        return dag



def compute_bids():
    while True:
        bids = vdx.GetBids()
        accepted_bids = vdx.Optimize(bids)
        print accepted_bids
        time.sleep(5)


#
# custom argparse handler to choose syslog levels
#
def loglevel(arg):
    levels = {
            0 : logging.CRITICAL,   # LOG_EMERG
            1 : logging.CRITICAL,   # LOG_ALERT
            2 : logging.CRITICAL,   # LOG_CRIT
            3 : logging.ERROR,      # LOG_ERR
            4 : logging.WARNING,    # LOG_WARNING
            5 : 25,                 # LOG_NOTICE
            6 : logging.INFO,       # LOG_INFO
            7 : logging.DEBUG       # LOG_DEBUG
            }
    try:
        value = int(arg)
    except ValueError as err:
       raise argparse.ArgumentTypeError(str(err))

    if value < 0 or value > 7:
        message = "Expected a value in 0..7, got {}".format(value)
        raise argparse.ArgumentTypeError(message)

    # now convert to a python logging level value
    return levels[value]


#
# set up system
#
def configure():
    random.seed() # FIXME - for initial testing only, not needed in real code

    parser = argparse.ArgumentParser(description='gather CDN stats')
    parser.add_argument('-v', '--version', action='version', version=VER)
    parser.add_argument('-V', '--verbose', action='store_true', help='enable console logging')
    parser.add_argument('-l', '--level', type=loglevel, help='set syslog level [0-7] (0=LOG_EMERG, 1=LOG_ALERT, 2=LOG_CRIT, 3=LOG_ERR, 4=LOG_WARNING, 5=LOG_NOTICE, 6=LOG_INFO, 7=LOG_DEBUG)')
    parser.add_argument('-f', '--file',    type=argparse.FileType('r'), help='cdn config file (default: %s)' % CONF)
    parser.add_argument('-p', '--port', help='broker port (default=%(default)s)')
    parser.set_defaults(file=CONFPATH, port=PORT, level=3)
    return parser.parse_args()

#
# initialize logging stuff
#
def initLogging():
    xlog = logging.getLogger()
    xlog.setLevel(args.level)

    formatter = logging.Formatter('broker: %(message)s')

    sysloghandler = logging.handlers.SysLogHandler('/dev/log')
    sysloghandler.setFormatter(formatter)
    xlog.addHandler(sysloghandler)

    if args.verbose:
        consolehandler = logging.StreamHandler()
        consolehandler.setFormatter(formatter)
        xlog.addHandler(consolehandler)


#
# let's go
#
def main():
    global args, scenario, vdx

    args = configure()
    initLogging()

    # initialize scenario and prime vdx engine
    scenario = Scenario(args.file)
    vdx.setup(scenario)

    # compute optimal CDNs in a background thread
    t = threading.Thread(target = compute_bids)
    t.start()

    # handle client connections
    # FIXME: need to change this to use xsockets
    t = ThreadedServer(Broker, port=44444)
    logging.info('Starting broker service on port %s' % args.port)
    t.start()

if __name__ == "__main__":
    main()

