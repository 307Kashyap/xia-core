#! /usr/bin/python
#
# Copyright 2012 Carnegie Mellon University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#	http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import time
import threading
import BaseHTTPServer
from SocketServer import ThreadingMixIn
from optparse import OptionParser

TITLE = "XIAStatsServer/0.1"
PORT = 8888
CONNECTIONS = '/connections'
FINAL = '/final'
NEXT = '/next'
STATS = '/stats'
EXPIRED = 10

connections = {}
final = {}
next = {}

c_lock = threading.Lock()
f_lock = threading.Lock()
n_lock = threading.Lock()

def say(msg):
	global options

	if options.verbose:
		print msg


def updateConnections(data):
	global c_lock

	lines = data.split()

	key = ''
	c = []
	for line in lines:
		(name, ad, hid, kind, port, next) = line.split(',')
		k = hid

		if k != key:
			if len(c) != 0:
				c_lock.acquire()
				connections[key] = c
				c_lock.release()
				c = []
			key = k

		c.append({'time': time.time(), 'data': line})

	if key != '':
		c_lock.acquire()
		connections[key] = c
		c_lock.release()



def getConnections():
	global c_lock

	s = ''

	c_lock.acquire()
	expired = time.time() - options.expired

	for c in connections.itervalues():

		# find unexpired entries
		# FIXME: change this to delete old entries and delete them instead of i
		# leaving them in the table
		c[:] = (cc for cc in c if cc['time'] > expired)

		for cc in c:
			s += cc['data'] + '\n'
	c_lock.release()

	return s


def updateStats1(data):
	global final
	global next
	global n_lock
	global f_lock

	for line in data.split():
		(kind, line) = line.split(',', 1)
		(hid, port, io, counts) = line.split(',', 3)
		key = ('%s:%s:%s') % (hid, port, io)

		if kind == 'final':
			f_lock.acquire()
			final[key] = line
			f_lock.release()
		else:
			n_lock.acquire()
			next[key] = line
			n_lock.release()


def updateStats(kind, data):
	global final
	global next
	global n_lock
	global f_lock

	for line in data.split():
		(hid, port, io, counts) = line.split(',', 3)
		key = ('%s:%s:%s') % (hid, port, io)
		if kind == 'final':
			f_lock.acquire()
			final[key] = line
			f_lock.release()
		else:
			n_lock.acquire()
			next[key] = line
			n_lock.release()


def getStats(kind):
	global final
	global next
	global n_lock
	global f_lock

	s = ''
	if kind == 'final':
		f_lock.acquire()
		for k, v in final.items():
			s += v + '\n'
		f_lock.release()
	else:
		n_lock.acquire()
		for k, v in next.items():
			s += v + '\n'
		n_lock.release()

	return s




class XIAStatsHandler(BaseHTTPServer.BaseHTTPRequestHandler):

	def do_GET(self):
#		print 'get: ', self.path
		if self.path == CONNECTIONS:
			self.wfile.write(getConnections())
		elif self.path == FINAL:
			self.wfile.write(getStats('final'))
		elif self.path == NEXT:
			self.wfile.write(getStats('next'))
		else:
			self.send_response(404)


	def do_POST(self):
#		print "post"
		self.wfile.write("post")


	def do_PUT(self):
		content_len = int(self.headers.getheader('content-length'))
		data = self.rfile.read(content_len)

		if self.path == CONNECTIONS:
			updateConnections(data)

		elif self.path == STATS:
			updateStats1(data)

#		elif self.path == FINAL:
#			updateStats('final', data)
#
#		elif self.path == NEXT:
#			updateStats('next', data)

		else:
			print 'bad request: ', self.path
			self.send_response(404)
			return

		self.send_response(200)


class MultiThreadedHTTPServer(ThreadingMixIn, BaseHTTPServer.HTTPServer):
    pass


def main(server_class=MultiThreadedHTTPServer, handler_class=XIAStatsHandler):

	global options

	parser = OptionParser()
	parser.add_option("-v", "--verbose", dest="verbose", help="print status messages", default=False, action="store_true")
	parser.add_option("-p", "--port", dest="port", help="stats server port", default=PORT)
	parser.add_option("-e", "--expired", dest="expired", type='int', help="connection table expiration time", default=EXPIRED)

	(options, args) = parser.parse_args()

	say(TITLE)

	server_address = ('', options.port)
	httpd = server_class(server_address, handler_class)
	httpd.server_version = TITLE
	try:
		httpd.serve_forever()
	except KeyboardInterrupt:
		print

if __name__ == '__main__':
	main()
