#! /usr/bin/python
#
# Copyright 2012 Carnegie Mellon University
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#	http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import os
import sys
import time
import socket
import requests
import clicksock
import telnetlib
from optparse import OptionParser

srcdir = os.getcwd()[:os.getcwd().rindex('xia-core')+len('xia-core')]
sys.path.append(os.path.join(srcdir, "bin"))
import xiapyutils


# default Click host and port
CLICK = "localhost"
CLICK_PORT = 7777

# stats server URLs
PORT = '8888'
STATS_HOST = 'localhost'
CONNECT_PATH = '/connections'
STATS_PATH = '/stats'
FINAL_PATH = '/final'
NEXT_PATH = '/next'

# retrieval intervals
STATS_INTERVAL = 1
ROUTE_INTERVAL = 1

# Minimum Click version required
MAJOR = 1
MINOR = 3

# config variables
MAX_PORTS = 8


#
# print the message if configured to be noisy
#
def say(msg):
	if options.verbose:
		print msg

#
# XIA Route table entry
#
class Route:
	def __init__(self, kind, text):
		self.kind = kind
		(self.xid, self.port, self.nexthop, self.flags) = text.split(',')


	def __repr__(self):
		return "Route(kind=%s, xid=%s, port=%s, flags=%s, nexthop=%s)" % (self.kind, self.xid, self.port, self.flags, self.nexthop)


#
# XIA Host/Router definition
#
class Router:
	def __init__(self, name, num_ports):
		self.name = name
		self.hid = None
		self.ad = None
		self.routes = []
		self.connections = []
		self.nextStats = {}
		self.finalStats = {}
		self.nextStatsIp = {}
		self.finalStatsIp = {}
		self.max_ports = num_ports
		self.ports = []

		for port in range(0, self.max_ports):
			k = '%d:IN' % (port)
			self.finalStatsIp[k] = Stats('final')
			self.nextStatsIp[k] = Stats('next')
			k = '%d:OUT' % (port)
			self.finalStatsIp[k] = Stats('final')
			self.nextStatsIp[k] = Stats('next')


	def addRoute(self, r):
		self.routes.append(r)
		port = int(r.port)
		kind = r.kind
		next = r.nexthop

		# ignore fallback, etc ports
		if port >= self.max_ports or port < -2:
			return

		# if port is -2, get our ad or hid from the route line
		if port == -2:
			if kind == 'AD':
				self.ad = r.xid
			elif kind == 'HID':
				self.hid = r.xid
			return

		if kind == 'IP':
			return #TODO: next hop for IP on endhost has some problem
			if port >= 0 and port < self.max_ports:
				if next == None or next == '':
					next = '-'

		elif port >= 0 and port < self.max_ports:
			kind = 'XID'
			if next == None:
				return

		if port not in self.nextStats:
			self.nextStats[port] = Stats('next')
		if port not in self.finalStats:
			self.finalStats[port] = Stats('final')
		if port not in self.ports:
			self.ports.append(port)

		c = Connection(port, kind, next)
		self.addConnection(c)


	def addConnection(self, c):
		for cc in self.connections:
			if cc.port == c.port and cc.next == c.next and cc.kind == c.kind:
				return
		self.connections.append(c)


	def reset(self):
		self.connections = []
		self.routes = []


	def __repr__(self):
		first = 1
		s = "Router(name=%s, hid=%s, ad=%s, connections=[" % (self.name, self.hid, self.ad)
		for c in self.connections:
			if first:
				first = 0
			else:
				s += ', '
			s += repr(c)
		s += '])'
		return s


	def csv(self):
		s = ''
		for c in self.connections:
			s += "%s,%s,%s,%s\n" % (self.name, self.ad, self.hid, c.csv())
		return s

#
# route info disitlled into an easier to manage object
#
class Connection:
	def __init__(self, port, kind, next):
		self.port = port
		self.kind = kind
		self.next = next


	def __repr__(self):
		return "Connection(kind=%s, port=%d, next=%s)" % (self.kind, self.port, self.next)


	def csv(self):
		return "%d,%s,%s" % (self.port, self.kind, self.next)

#
# XIA routers/hosts
#
class Device:

	def __init__(self, name):
		self.dualStack = False
		self.router = None
		self.name = name

	def parse(self, conf):
		if conf.find('XIARouter8Port') >= 0:
			ports = 8
		else:
			ports = 4

		if conf.find('DualRouter') >= 0:
			self.dualStack = True

		self.router = Router(self.name, ports)

	def resetRoutes(self):
			self.router.reset()


	def __repr__(self):
		first = 1
		s = "Device({"
		s += self.name + " : " + repr(self.router)
		s += '})'
		return s


	def csv(self):
		s = self.router.csv()
		return s

#
# statistics
#
class Stats:
	def __init__(self, name):
		self.data = {}
		self.last = {}
		self.name = name
		self.timestamp = 0
		for xid in ('AD', 'HID', 'SID', 'CID', 'IP', 'FID', 'UNKNOWN'):
			self.data[xid] = 0
			self.last[xid] = 0


	def update(self, text, name):
		cur = time.time()

		(ad, hid, sid, cid, ip, fid, unknown) = text.split()
		ad = int(ad)
		hid = int(hid)
		sid = int(sid)
		cid = int(cid)
		ip = int(ip)
		fid = int(fid)
		unknown = int(unknown)

		if self.timestamp != 0:
			elapsed = int(max(1, cur - self.timestamp))
			self.data['AD'] = (ad - self.last['AD']) / elapsed
			self.data['HID'] = (hid - self.last['HID']) / elapsed
			self.data['SID'] = (sid - self.last['SID']) / elapsed
			self.data['CID'] = (cid - self.last['CID']) / elapsed
			self.data['IP'] = (ip - self.last['IP']) /elapsed
			self.data['FID'] = (fid - self.last['FID']) /elapsed
			self.data['UNKNOWN'] = (unknown - self.last['UNKNOWN']) / elapsed

		self.timestamp = cur
		self.last['AD'] = ad
		self.last['HID'] = hid
		self.last['SID'] = sid
		self.last['CID'] = cid
		self.last['IP'] = ip
		self.last['FID'] = fid
		self.last['UNKNOWN'] = unknown


	def csv(self):
		return "%d,%d,%d,%d,%d,%d,%d,0,0,0,0,0,0,0" % (self.data['AD'], self.data['HID'], self.data['SID'], self.data['CID'], self.data['IP'], self.data['FID'], self.data['UNKNOWN'])


#
# get the route entries for each of the devices and populate the router objects
#
def updateRoutes(click):
	device.resetRoutes()
	for kind in ('AD', 'HID', 'IP'):
		lines = click.readData("%s/xrc/n/proc/rt_%s.list" % (device.name, kind))

		for line in lines.splitlines():
			rt = Route(kind, line)
			device.router.addRoute(rt)

	return device.csv()


def getCounts(s):
	if s == None:
		return None

	counts = s.splitlines()
	if len(counts) == 1:
		ip = counts[0][7:]
		s = "0 0 0 0 %s 0 0" % (ip)

	else:
		# FIXME: we need to add support for ncid's to statsserver and the visualizer
		# just throwing them away for now

		ad, hid, sid, cid, ip, fid, ncid, unknown = s.splitlines()
		#ad, hid, sid, cid, ip, unknown = s.splitlines()
		ad  = ad[7:]
		hid = hid[7:]
		sid = sid[7:]
		cid = cid[7:]
		ip  = ip[7:]
		fid = fid[7:]
		ncid = ncid[7:]
		#fid = 0
		unknown = unknown[7:]
		s = "%s %s %s %s %s %s %s" % (ad, hid, sid, cid, ip, fid, unknown)

	return s


def updateDualStats(click, kind):
	s = ''
	for port in range(0, 4):

		counts = getCounts(click.readData("%s/dualrouter_%s_%d.count" % (device.name, kind, port)))
		fromip = getCounts(click.readData("%s/dualrouter_fromip_%s_%d.count" % (device.name, kind, port)))

		kin = '%d:IN' % (port)
		kout = '%d:OUT' % (port)

		if kind == 'final':
			if counts != None:
				device.router.finalStatsIp[kout].update(counts, device.name)
				s += '%s,%s,%d,OUT,%s\n' % (kind, device.router.hid, port, device.finalStatsIp[kout].csv())
			if fromip != None:
				device.router.finalStatsIp[kin].update(fromip, device.name)
				s += '%s,%s,%d,IN,%s\n' % (kind, device.router.hid, port, device.finalStatsIp[kin].csv())

		else:
			if counts != None:
				device.router.nextStatsIp[kout].update(counts, device.name)
				s += '%s,%s,%d,OUT,%s\n' % (kind, device.router.hid, port, device.nextStatsIp[kout].csv())
			if fromip != None:
				device.router.nextStatsIp[kin].update(fromip, device.name)
				s += '%s,%s,%d,IN,%s\n' % (kind, device.router.hid, port, device.nextStatsIp[kin].csv())

				print s
	return s


def updateStats(click, kind):
	s = ''
	for port in device.router.ports: #a router: xlc#port
		counts = getCounts(click.readData("%s/xlc%d/count_%s_out.count" % (device.name, port, kind)))
		if counts == None:
			continue

		if kind == 'final':
			device.router.finalStats[port].update(counts, device.name)
			txt= '%s,%s,%d,OUT,%s\n' % (kind, device.router.hid, port, device.router.finalStats[port].csv())
			s += txt

		else:
			device.router.nextStats[port].update(counts, device.name)
			s += '%s,%s,%d,OUT,%s\n' % (kind, device.router.hid, port, device.router.nextStats[port].csv())

	return s



def sendData(path, data):
	global base_url

	try:
		req = requests.put(base_url + path, data=data)
	except:
		say ('PUT ' + path + ' failed')


#
# go speed racer go!
#
def main():
	global device
	global options
	global base_url

	print "starting"
	parser = OptionParser()
	parser.add_option("-c", "--click", dest="click", help="Click instance address", default=CLICK)
	parser.add_option("-s", "--server", dest="host", help="Stats server host", default=STATS_HOST)
	parser.add_option("-p", "--port", dest="port", help="Stats server port", default=PORT)
	parser.add_option("-i", "--interval", dest="stats_interval", type='int', help="stats update interval", default=STATS_INTERVAL)
	parser.add_option("-r", "--rinterval", dest="route_interval", type='int', help="connections update interval", default=ROUTE_INTERVAL)
	parser.add_option("-v", "--verbose", dest="verbose", help="print status messages", default=False, action="store_true")
	(options, args) = parser.parse_args()

	hostname = xiapyutils.getxiaclickhostname()

	with clicksock.clicksock() as click:
		# get the list of hosts/routers from clock
		device = Device(hostname)
		device.parse(click.readData("config"))

		print device

		rts = updateRoutes(click)
		sendData(CONNECT_PATH, rts)

		# query and send info to the stats server
		base_url = 'http://%s:%s' %(options.host, options.port)
		lastStat = lastRoute = 0
		try:
			while 1:
				now = time.time()
				if now - lastStat > options.stats_interval:
					lastStat = now

					if device.dualStack:
						s = updateDualStats(click, 'final')
						s += updateDualStats(click, 'next')
						if s != '':
							sendData(STATS_PATH, s)

					s = updateStats(click, 'final')
					s += updateStats(click, 'next')
					if s != '':
						sendData(STATS_PATH, s)

				if now - lastRoute > options.route_interval:
					lastRoute = now
					rts = updateRoutes(click)
					sendData(CONNECT_PATH, rts)

				time.sleep(1)
		except KeyboardInterrupt:
			print

		click.shutdown()


if __name__ == "__main__":
	main()
