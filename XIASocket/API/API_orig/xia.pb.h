// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xia.proto

#ifndef PROTOBUF_xia_2eproto__INCLUDED
#define PROTOBUF_xia_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_message_reflection.h>
// @@protoc_insertion_point(includes)

namespace xia {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_xia_2eproto();
void protobuf_AssignDesc_xia_2eproto();
void protobuf_ShutdownFile_xia_2eproto();

class XSocketMsg;
class X_Socket_Msg;
class X_Bind_Msg;
class X_Close_Msg;
class X_Connect_Msg;
class X_Accept_Msg;
class X_Putcid_Msg;
class X_Getcid_Msg;
class X_Sendto_Msg;
class X_Send_Msg;
class X_Recv_Msg;
class X_Recvfrom_Msg;
class X_Getsocketidlist_Msg;
class X_Getsocketinfo_Msg;
class msg;
class msg_response;

enum msg_MsgType {
  msg_MsgType_GETLOCALHID = 0,
  msg_MsgType_GETCID = 1,
  msg_MsgType_CONNECTSID = 2,
  msg_MsgType_PUTCID = 3,
  msg_MsgType_SERVESID = 4
};
bool msg_MsgType_IsValid(int value);
const msg_MsgType msg_MsgType_MsgType_MIN = msg_MsgType_GETLOCALHID;
const msg_MsgType msg_MsgType_MsgType_MAX = msg_MsgType_SERVESID;
const int msg_MsgType_MsgType_ARRAYSIZE = msg_MsgType_MsgType_MAX + 1;

const ::google::protobuf::EnumDescriptor* msg_MsgType_descriptor();
inline const ::std::string& msg_MsgType_Name(msg_MsgType value) {
  return ::google::protobuf::internal::NameOfEnum(
    msg_MsgType_descriptor(), value);
}
inline bool msg_MsgType_Parse(
    const ::std::string& name, msg_MsgType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<msg_MsgType>(
    msg_MsgType_descriptor(), name, value);
}
enum XSocketCallType {
  XSOCKET = 0,
  XBIND = 1,
  XCLOSE = 2,
  XCONNECT = 3,
  XACCEPT = 4,
  XPUTCID = 5,
  XGETCID = 6,
  XSENDTO = 7,
  XSEND = 8,
  XRECV = 9,
  XRECVFROM = 10,
  XSOCKET_REQUEST_FAILED = 11,
  XGETSOCKETIDLIST = 12,
  XGETSOCKETINFO = 13
};
bool XSocketCallType_IsValid(int value);
const XSocketCallType XSocketCallType_MIN = XSOCKET;
const XSocketCallType XSocketCallType_MAX = XGETSOCKETINFO;
const int XSocketCallType_ARRAYSIZE = XSocketCallType_MAX + 1;

const ::google::protobuf::EnumDescriptor* XSocketCallType_descriptor();
inline const ::std::string& XSocketCallType_Name(XSocketCallType value) {
  return ::google::protobuf::internal::NameOfEnum(
    XSocketCallType_descriptor(), value);
}
inline bool XSocketCallType_Parse(
    const ::std::string& name, XSocketCallType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XSocketCallType>(
    XSocketCallType_descriptor(), name, value);
}
// ===================================================================

class XSocketMsg : public ::google::protobuf::Message {
 public:
  XSocketMsg();
  virtual ~XSocketMsg();
  
  XSocketMsg(const XSocketMsg& from);
  
  inline XSocketMsg& operator=(const XSocketMsg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const XSocketMsg& default_instance();
  
  void Swap(XSocketMsg* other);
  
  // implements Message ----------------------------------------------
  
  XSocketMsg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XSocketMsg& from);
  void MergeFrom(const XSocketMsg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required .xia.XSocketCallType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline xia::XSocketCallType type() const;
  inline void set_type(xia::XSocketCallType value);
  
  // optional .xia.X_Socket_Msg x_socket = 2;
  inline bool has_x_socket() const;
  inline void clear_x_socket();
  static const int kXSocketFieldNumber = 2;
  inline const ::xia::X_Socket_Msg& x_socket() const;
  inline ::xia::X_Socket_Msg* mutable_x_socket();
  
  // optional .xia.X_Bind_Msg x_bind = 3;
  inline bool has_x_bind() const;
  inline void clear_x_bind();
  static const int kXBindFieldNumber = 3;
  inline const ::xia::X_Bind_Msg& x_bind() const;
  inline ::xia::X_Bind_Msg* mutable_x_bind();
  
  // optional .xia.X_Close_Msg x_close = 4;
  inline bool has_x_close() const;
  inline void clear_x_close();
  static const int kXCloseFieldNumber = 4;
  inline const ::xia::X_Close_Msg& x_close() const;
  inline ::xia::X_Close_Msg* mutable_x_close();
  
  // optional .xia.X_Connect_Msg x_connect = 5;
  inline bool has_x_connect() const;
  inline void clear_x_connect();
  static const int kXConnectFieldNumber = 5;
  inline const ::xia::X_Connect_Msg& x_connect() const;
  inline ::xia::X_Connect_Msg* mutable_x_connect();
  
  // optional .xia.X_Accept_Msg x_accept = 6;
  inline bool has_x_accept() const;
  inline void clear_x_accept();
  static const int kXAcceptFieldNumber = 6;
  inline const ::xia::X_Accept_Msg& x_accept() const;
  inline ::xia::X_Accept_Msg* mutable_x_accept();
  
  // optional .xia.X_Putcid_Msg x_putcid = 7;
  inline bool has_x_putcid() const;
  inline void clear_x_putcid();
  static const int kXPutcidFieldNumber = 7;
  inline const ::xia::X_Putcid_Msg& x_putcid() const;
  inline ::xia::X_Putcid_Msg* mutable_x_putcid();
  
  // optional .xia.X_Getcid_Msg x_getcid = 8;
  inline bool has_x_getcid() const;
  inline void clear_x_getcid();
  static const int kXGetcidFieldNumber = 8;
  inline const ::xia::X_Getcid_Msg& x_getcid() const;
  inline ::xia::X_Getcid_Msg* mutable_x_getcid();
  
  // optional .xia.X_Sendto_Msg x_sendto = 9;
  inline bool has_x_sendto() const;
  inline void clear_x_sendto();
  static const int kXSendtoFieldNumber = 9;
  inline const ::xia::X_Sendto_Msg& x_sendto() const;
  inline ::xia::X_Sendto_Msg* mutable_x_sendto();
  
  // optional .xia.X_Send_Msg x_send = 10;
  inline bool has_x_send() const;
  inline void clear_x_send();
  static const int kXSendFieldNumber = 10;
  inline const ::xia::X_Send_Msg& x_send() const;
  inline ::xia::X_Send_Msg* mutable_x_send();
  
  // optional .xia.X_Recv_Msg x_recv = 11;
  inline bool has_x_recv() const;
  inline void clear_x_recv();
  static const int kXRecvFieldNumber = 11;
  inline const ::xia::X_Recv_Msg& x_recv() const;
  inline ::xia::X_Recv_Msg* mutable_x_recv();
  
  // optional .xia.X_Recvfrom_Msg x_recvfrom = 12;
  inline bool has_x_recvfrom() const;
  inline void clear_x_recvfrom();
  static const int kXRecvfromFieldNumber = 12;
  inline const ::xia::X_Recvfrom_Msg& x_recvfrom() const;
  inline ::xia::X_Recvfrom_Msg* mutable_x_recvfrom();
  
  // optional .xia.X_Getsocketidlist_Msg x_getsocketidlist = 13;
  inline bool has_x_getsocketidlist() const;
  inline void clear_x_getsocketidlist();
  static const int kXGetsocketidlistFieldNumber = 13;
  inline const ::xia::X_Getsocketidlist_Msg& x_getsocketidlist() const;
  inline ::xia::X_Getsocketidlist_Msg* mutable_x_getsocketidlist();
  
  // optional .xia.X_Getsocketinfo_Msg x_getsocketinfo = 14;
  inline bool has_x_getsocketinfo() const;
  inline void clear_x_getsocketinfo();
  static const int kXGetsocketinfoFieldNumber = 14;
  inline const ::xia::X_Getsocketinfo_Msg& x_getsocketinfo() const;
  inline ::xia::X_Getsocketinfo_Msg* mutable_x_getsocketinfo();
  
  // @@protoc_insertion_point(class_scope:xia.XSocketMsg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  int type_;
  ::xia::X_Socket_Msg* x_socket_;
  ::xia::X_Bind_Msg* x_bind_;
  ::xia::X_Close_Msg* x_close_;
  ::xia::X_Connect_Msg* x_connect_;
  ::xia::X_Accept_Msg* x_accept_;
  ::xia::X_Putcid_Msg* x_putcid_;
  ::xia::X_Getcid_Msg* x_getcid_;
  ::xia::X_Sendto_Msg* x_sendto_;
  ::xia::X_Send_Msg* x_send_;
  ::xia::X_Recv_Msg* x_recv_;
  ::xia::X_Recvfrom_Msg* x_recvfrom_;
  ::xia::X_Getsocketidlist_Msg* x_getsocketidlist_;
  ::xia::X_Getsocketinfo_Msg* x_getsocketinfo_;
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static XSocketMsg* default_instance_;
};
// -------------------------------------------------------------------

class X_Socket_Msg : public ::google::protobuf::Message {
 public:
  X_Socket_Msg();
  virtual ~X_Socket_Msg();
  
  X_Socket_Msg(const X_Socket_Msg& from);
  
  inline X_Socket_Msg& operator=(const X_Socket_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Socket_Msg& default_instance();
  
  void Swap(X_Socket_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Socket_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Socket_Msg& from);
  void MergeFrom(const X_Socket_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);
  
  // optional string temp = 2;
  inline bool has_temp() const;
  inline void clear_temp();
  static const int kTempFieldNumber = 2;
  inline const ::std::string& temp() const;
  inline void set_temp(const ::std::string& value);
  inline void set_temp(const char* value);
  inline void set_temp(const char* value, size_t size);
  inline ::std::string* mutable_temp();
  
  // @@protoc_insertion_point(class_scope:xia.X_Socket_Msg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 type_;
  ::std::string* temp_;
  static const ::std::string _default_temp_;
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static X_Socket_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Bind_Msg : public ::google::protobuf::Message {
 public:
  X_Bind_Msg();
  virtual ~X_Bind_Msg();
  
  X_Bind_Msg(const X_Bind_Msg& from);
  
  inline X_Bind_Msg& operator=(const X_Bind_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Bind_Msg& default_instance();
  
  void Swap(X_Bind_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Bind_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Bind_Msg& from);
  void MergeFrom(const X_Bind_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string sdag = 1;
  inline bool has_sdag() const;
  inline void clear_sdag();
  static const int kSdagFieldNumber = 1;
  inline const ::std::string& sdag() const;
  inline void set_sdag(const ::std::string& value);
  inline void set_sdag(const char* value);
  inline void set_sdag(const char* value, size_t size);
  inline ::std::string* mutable_sdag();
  
  // @@protoc_insertion_point(class_scope:xia.X_Bind_Msg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* sdag_;
  static const ::std::string _default_sdag_;
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static X_Bind_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Close_Msg : public ::google::protobuf::Message {
 public:
  X_Close_Msg();
  virtual ~X_Close_Msg();
  
  X_Close_Msg(const X_Close_Msg& from);
  
  inline X_Close_Msg& operator=(const X_Close_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Close_Msg& default_instance();
  
  void Swap(X_Close_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Close_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Close_Msg& from);
  void MergeFrom(const X_Close_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional bytes payload = 1;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 1;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  
  // @@protoc_insertion_point(class_scope:xia.X_Close_Msg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* payload_;
  static const ::std::string _default_payload_;
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static X_Close_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Connect_Msg : public ::google::protobuf::Message {
 public:
  X_Connect_Msg();
  virtual ~X_Connect_Msg();
  
  X_Connect_Msg(const X_Connect_Msg& from);
  
  inline X_Connect_Msg& operator=(const X_Connect_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Connect_Msg& default_instance();
  
  void Swap(X_Connect_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Connect_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Connect_Msg& from);
  void MergeFrom(const X_Connect_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ddag = 1;
  inline bool has_ddag() const;
  inline void clear_ddag();
  static const int kDdagFieldNumber = 1;
  inline const ::std::string& ddag() const;
  inline void set_ddag(const ::std::string& value);
  inline void set_ddag(const char* value);
  inline void set_ddag(const char* value, size_t size);
  inline ::std::string* mutable_ddag();
  
  // @@protoc_insertion_point(class_scope:xia.X_Connect_Msg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* ddag_;
  static const ::std::string _default_ddag_;
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static X_Connect_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Accept_Msg : public ::google::protobuf::Message {
 public:
  X_Accept_Msg();
  virtual ~X_Accept_Msg();
  
  X_Accept_Msg(const X_Accept_Msg& from);
  
  inline X_Accept_Msg& operator=(const X_Accept_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Accept_Msg& default_instance();
  
  void Swap(X_Accept_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Accept_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Accept_Msg& from);
  void MergeFrom(const X_Accept_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string temp = 1;
  inline bool has_temp() const;
  inline void clear_temp();
  static const int kTempFieldNumber = 1;
  inline const ::std::string& temp() const;
  inline void set_temp(const ::std::string& value);
  inline void set_temp(const char* value);
  inline void set_temp(const char* value, size_t size);
  inline ::std::string* mutable_temp();
  
  // @@protoc_insertion_point(class_scope:xia.X_Accept_Msg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* temp_;
  static const ::std::string _default_temp_;
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static X_Accept_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Putcid_Msg : public ::google::protobuf::Message {
 public:
  X_Putcid_Msg();
  virtual ~X_Putcid_Msg();
  
  X_Putcid_Msg(const X_Putcid_Msg& from);
  
  inline X_Putcid_Msg& operator=(const X_Putcid_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Putcid_Msg& default_instance();
  
  void Swap(X_Putcid_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Putcid_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Putcid_Msg& from);
  void MergeFrom(const X_Putcid_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string sdag = 1;
  inline bool has_sdag() const;
  inline void clear_sdag();
  static const int kSdagFieldNumber = 1;
  inline const ::std::string& sdag() const;
  inline void set_sdag(const ::std::string& value);
  inline void set_sdag(const char* value);
  inline void set_sdag(const char* value, size_t size);
  inline ::std::string* mutable_sdag();
  
  // required bytes payload = 2;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 2;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  
  // @@protoc_insertion_point(class_scope:xia.X_Putcid_Msg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* sdag_;
  static const ::std::string _default_sdag_;
  ::std::string* payload_;
  static const ::std::string _default_payload_;
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static X_Putcid_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Getcid_Msg : public ::google::protobuf::Message {
 public:
  X_Getcid_Msg();
  virtual ~X_Getcid_Msg();
  
  X_Getcid_Msg(const X_Getcid_Msg& from);
  
  inline X_Getcid_Msg& operator=(const X_Getcid_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Getcid_Msg& default_instance();
  
  void Swap(X_Getcid_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Getcid_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Getcid_Msg& from);
  void MergeFrom(const X_Getcid_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string temp = 1;
  inline bool has_temp() const;
  inline void clear_temp();
  static const int kTempFieldNumber = 1;
  inline const ::std::string& temp() const;
  inline void set_temp(const ::std::string& value);
  inline void set_temp(const char* value);
  inline void set_temp(const char* value, size_t size);
  inline ::std::string* mutable_temp();
  
  // @@protoc_insertion_point(class_scope:xia.X_Getcid_Msg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* temp_;
  static const ::std::string _default_temp_;
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static X_Getcid_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Sendto_Msg : public ::google::protobuf::Message {
 public:
  X_Sendto_Msg();
  virtual ~X_Sendto_Msg();
  
  X_Sendto_Msg(const X_Sendto_Msg& from);
  
  inline X_Sendto_Msg& operator=(const X_Sendto_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Sendto_Msg& default_instance();
  
  void Swap(X_Sendto_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Sendto_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Sendto_Msg& from);
  void MergeFrom(const X_Sendto_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required string ddag = 1;
  inline bool has_ddag() const;
  inline void clear_ddag();
  static const int kDdagFieldNumber = 1;
  inline const ::std::string& ddag() const;
  inline void set_ddag(const ::std::string& value);
  inline void set_ddag(const char* value);
  inline void set_ddag(const char* value, size_t size);
  inline ::std::string* mutable_ddag();
  
  // required bytes payload = 2;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 2;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  
  // @@protoc_insertion_point(class_scope:xia.X_Sendto_Msg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* ddag_;
  static const ::std::string _default_ddag_;
  ::std::string* payload_;
  static const ::std::string _default_payload_;
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static X_Sendto_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Send_Msg : public ::google::protobuf::Message {
 public:
  X_Send_Msg();
  virtual ~X_Send_Msg();
  
  X_Send_Msg(const X_Send_Msg& from);
  
  inline X_Send_Msg& operator=(const X_Send_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Send_Msg& default_instance();
  
  void Swap(X_Send_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Send_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Send_Msg& from);
  void MergeFrom(const X_Send_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required bytes payload = 1;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 1;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  
  // @@protoc_insertion_point(class_scope:xia.X_Send_Msg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* payload_;
  static const ::std::string _default_payload_;
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static X_Send_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Recv_Msg : public ::google::protobuf::Message {
 public:
  X_Recv_Msg();
  virtual ~X_Recv_Msg();
  
  X_Recv_Msg(const X_Recv_Msg& from);
  
  inline X_Recv_Msg& operator=(const X_Recv_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Recv_Msg& default_instance();
  
  void Swap(X_Recv_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Recv_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Recv_Msg& from);
  void MergeFrom(const X_Recv_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string temp = 1;
  inline bool has_temp() const;
  inline void clear_temp();
  static const int kTempFieldNumber = 1;
  inline const ::std::string& temp() const;
  inline void set_temp(const ::std::string& value);
  inline void set_temp(const char* value);
  inline void set_temp(const char* value, size_t size);
  inline ::std::string* mutable_temp();
  
  // @@protoc_insertion_point(class_scope:xia.X_Recv_Msg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* temp_;
  static const ::std::string _default_temp_;
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static X_Recv_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Recvfrom_Msg : public ::google::protobuf::Message {
 public:
  X_Recvfrom_Msg();
  virtual ~X_Recvfrom_Msg();
  
  X_Recvfrom_Msg(const X_Recvfrom_Msg& from);
  
  inline X_Recvfrom_Msg& operator=(const X_Recvfrom_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Recvfrom_Msg& default_instance();
  
  void Swap(X_Recvfrom_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Recvfrom_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Recvfrom_Msg& from);
  void MergeFrom(const X_Recvfrom_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional string temp = 1;
  inline bool has_temp() const;
  inline void clear_temp();
  static const int kTempFieldNumber = 1;
  inline const ::std::string& temp() const;
  inline void set_temp(const ::std::string& value);
  inline void set_temp(const char* value);
  inline void set_temp(const char* value, size_t size);
  inline ::std::string* mutable_temp();
  
  // @@protoc_insertion_point(class_scope:xia.X_Recvfrom_Msg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::std::string* temp_;
  static const ::std::string _default_temp_;
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static X_Recvfrom_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Getsocketidlist_Msg : public ::google::protobuf::Message {
 public:
  X_Getsocketidlist_Msg();
  virtual ~X_Getsocketidlist_Msg();
  
  X_Getsocketidlist_Msg(const X_Getsocketidlist_Msg& from);
  
  inline X_Getsocketidlist_Msg& operator=(const X_Getsocketidlist_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Getsocketidlist_Msg& default_instance();
  
  void Swap(X_Getsocketidlist_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Getsocketidlist_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Getsocketidlist_Msg& from);
  void MergeFrom(const X_Getsocketidlist_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // optional int32 size = 1;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 1;
  inline ::google::protobuf::int32 size() const;
  inline void set_size(::google::protobuf::int32 value);
  
  // repeated int32 id = 2;
  inline int id_size() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id(int index) const;
  inline void set_id(int index, ::google::protobuf::int32 value);
  inline void add_id(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      id() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_id();
  
  // @@protoc_insertion_point(class_scope:xia.X_Getsocketidlist_Msg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > id_;
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static X_Getsocketidlist_Msg* default_instance_;
};
// -------------------------------------------------------------------

class X_Getsocketinfo_Msg : public ::google::protobuf::Message {
 public:
  X_Getsocketinfo_Msg();
  virtual ~X_Getsocketinfo_Msg();
  
  X_Getsocketinfo_Msg(const X_Getsocketinfo_Msg& from);
  
  inline X_Getsocketinfo_Msg& operator=(const X_Getsocketinfo_Msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const X_Getsocketinfo_Msg& default_instance();
  
  void Swap(X_Getsocketinfo_Msg* other);
  
  // implements Message ----------------------------------------------
  
  X_Getsocketinfo_Msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const X_Getsocketinfo_Msg& from);
  void MergeFrom(const X_Getsocketinfo_Msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);
  
  // optional int32 port = 2;
  inline bool has_port() const;
  inline void clear_port();
  static const int kPortFieldNumber = 2;
  inline ::google::protobuf::int32 port() const;
  inline void set_port(::google::protobuf::int32 value);
  
  // optional bytes status = 3;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 3;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const void* value, size_t size);
  inline ::std::string* mutable_status();
  
  // optional bytes xid = 4;
  inline bool has_xid() const;
  inline void clear_xid();
  static const int kXidFieldNumber = 4;
  inline const ::std::string& xid() const;
  inline void set_xid(const ::std::string& value);
  inline void set_xid(const char* value);
  inline void set_xid(const void* value, size_t size);
  inline ::std::string* mutable_xid();
  
  // optional bytes xiapath_src = 5;
  inline bool has_xiapath_src() const;
  inline void clear_xiapath_src();
  static const int kXiapathSrcFieldNumber = 5;
  inline const ::std::string& xiapath_src() const;
  inline void set_xiapath_src(const ::std::string& value);
  inline void set_xiapath_src(const char* value);
  inline void set_xiapath_src(const void* value, size_t size);
  inline ::std::string* mutable_xiapath_src();
  
  // optional bytes xiapath_dst = 6;
  inline bool has_xiapath_dst() const;
  inline void clear_xiapath_dst();
  static const int kXiapathDstFieldNumber = 6;
  inline const ::std::string& xiapath_dst() const;
  inline void set_xiapath_dst(const ::std::string& value);
  inline void set_xiapath_dst(const char* value);
  inline void set_xiapath_dst(const void* value, size_t size);
  inline ::std::string* mutable_xiapath_dst();
  
  // optional bytes protocol = 7;
  inline bool has_protocol() const;
  inline void clear_protocol();
  static const int kProtocolFieldNumber = 7;
  inline const ::std::string& protocol() const;
  inline void set_protocol(const ::std::string& value);
  inline void set_protocol(const char* value);
  inline void set_protocol(const void* value, size_t size);
  inline ::std::string* mutable_protocol();
  
  // @@protoc_insertion_point(class_scope:xia.X_Getsocketinfo_Msg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 port_;
  ::std::string* status_;
  static const ::std::string _default_status_;
  ::std::string* xid_;
  static const ::std::string _default_xid_;
  ::std::string* xiapath_src_;
  static const ::std::string _default_xiapath_src_;
  ::std::string* xiapath_dst_;
  static const ::std::string _default_xiapath_dst_;
  ::std::string* protocol_;
  static const ::std::string _default_protocol_;
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static X_Getsocketinfo_Msg* default_instance_;
};
// -------------------------------------------------------------------

class msg : public ::google::protobuf::Message {
 public:
  msg();
  virtual ~msg();
  
  msg(const msg& from);
  
  inline msg& operator=(const msg& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const msg& default_instance();
  
  void Swap(msg* other);
  
  // implements Message ----------------------------------------------
  
  msg* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg& from);
  void MergeFrom(const msg& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  typedef msg_MsgType MsgType;
  static const MsgType GETLOCALHID = msg_MsgType_GETLOCALHID;
  static const MsgType GETCID = msg_MsgType_GETCID;
  static const MsgType CONNECTSID = msg_MsgType_CONNECTSID;
  static const MsgType PUTCID = msg_MsgType_PUTCID;
  static const MsgType SERVESID = msg_MsgType_SERVESID;
  static inline bool MsgType_IsValid(int value) {
    return msg_MsgType_IsValid(value);
  }
  static const MsgType MsgType_MIN =
    msg_MsgType_MsgType_MIN;
  static const MsgType MsgType_MAX =
    msg_MsgType_MsgType_MAX;
  static const int MsgType_ARRAYSIZE =
    msg_MsgType_MsgType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  MsgType_descriptor() {
    return msg_MsgType_descriptor();
  }
  static inline const ::std::string& MsgType_Name(MsgType value) {
    return msg_MsgType_Name(value);
  }
  static inline bool MsgType_Parse(const ::std::string& name,
      MsgType* value) {
    return msg_MsgType_Parse(name, value);
  }
  
  // accessors -------------------------------------------------------
  
  // optional int32 appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);
  
  // optional bytes xid = 2;
  inline bool has_xid() const;
  inline void clear_xid();
  static const int kXidFieldNumber = 2;
  inline const ::std::string& xid() const;
  inline void set_xid(const ::std::string& value);
  inline void set_xid(const char* value);
  inline void set_xid(const void* value, size_t size);
  inline ::std::string* mutable_xid();
  
  // optional string xiapath_src = 5;
  inline bool has_xiapath_src() const;
  inline void clear_xiapath_src();
  static const int kXiapathSrcFieldNumber = 5;
  inline const ::std::string& xiapath_src() const;
  inline void set_xiapath_src(const ::std::string& value);
  inline void set_xiapath_src(const char* value);
  inline void set_xiapath_src(const char* value, size_t size);
  inline ::std::string* mutable_xiapath_src();
  
  // optional string xiapath_dst = 6;
  inline bool has_xiapath_dst() const;
  inline void clear_xiapath_dst();
  static const int kXiapathDstFieldNumber = 6;
  inline const ::std::string& xiapath_dst() const;
  inline void set_xiapath_dst(const ::std::string& value);
  inline void set_xiapath_dst(const char* value);
  inline void set_xiapath_dst(const char* value, size_t size);
  inline ::std::string* mutable_xiapath_dst();
  
  // optional bytes payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const void* value, size_t size);
  inline ::std::string* mutable_payload();
  
  // optional .xia.msg.MsgType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::xia::msg_MsgType type() const;
  inline void set_type(::xia::msg_MsgType value);
  
  // @@protoc_insertion_point(class_scope:xia.msg)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 appid_;
  ::std::string* xid_;
  static const ::std::string _default_xid_;
  ::std::string* xiapath_src_;
  static const ::std::string _default_xiapath_src_;
  ::std::string* xiapath_dst_;
  static const ::std::string _default_xiapath_dst_;
  ::std::string* payload_;
  static const ::std::string _default_payload_;
  int type_;
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static msg* default_instance_;
};
// -------------------------------------------------------------------

class msg_response : public ::google::protobuf::Message {
 public:
  msg_response();
  virtual ~msg_response();
  
  msg_response(const msg_response& from);
  
  inline msg_response& operator=(const msg_response& from) {
    CopyFrom(from);
    return *this;
  }
  
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }
  
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }
  
  static const ::google::protobuf::Descriptor* descriptor();
  static const msg_response& default_instance();
  
  void Swap(msg_response* other);
  
  // implements Message ----------------------------------------------
  
  msg_response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const msg_response& from);
  void MergeFrom(const msg_response& from);
  void Clear();
  bool IsInitialized() const;
  
  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  
  ::google::protobuf::Metadata GetMetadata() const;
  
  // nested types ----------------------------------------------------
  
  // accessors -------------------------------------------------------
  
  // required int32 appid = 1;
  inline bool has_appid() const;
  inline void clear_appid();
  static const int kAppidFieldNumber = 1;
  inline ::google::protobuf::int32 appid() const;
  inline void set_appid(::google::protobuf::int32 value);
  
  // repeated bytes xid = 2;
  inline int xid_size() const;
  inline void clear_xid();
  static const int kXidFieldNumber = 2;
  inline const ::std::string& xid(int index) const;
  inline ::std::string* mutable_xid(int index);
  inline void set_xid(int index, const ::std::string& value);
  inline void set_xid(int index, const char* value);
  inline void set_xid(int index, const void* value, size_t size);
  inline ::std::string* add_xid();
  inline void add_xid(const ::std::string& value);
  inline void add_xid(const char* value);
  inline void add_xid(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& xid() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_xid();
  
  // optional string payload = 3;
  inline bool has_payload() const;
  inline void clear_payload();
  static const int kPayloadFieldNumber = 3;
  inline const ::std::string& payload() const;
  inline void set_payload(const ::std::string& value);
  inline void set_payload(const char* value);
  inline void set_payload(const char* value, size_t size);
  inline ::std::string* mutable_payload();
  
  // @@protoc_insertion_point(class_scope:xia.msg_response)
 private:
  ::google::protobuf::UnknownFieldSet _unknown_fields_;
  mutable int _cached_size_;
  
  ::google::protobuf::int32 appid_;
  ::google::protobuf::RepeatedPtrField< ::std::string> xid_;
  ::std::string* payload_;
  static const ::std::string _default_payload_;
  friend void  protobuf_AddDesc_xia_2eproto();
  friend void protobuf_AssignDesc_xia_2eproto();
  friend void protobuf_ShutdownFile_xia_2eproto();
  
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];
  
  // WHY DOES & HAVE LOWER PRECEDENCE THAN != !?
  inline bool _has_bit(int index) const {
    return (_has_bits_[index / 32] & (1u << (index % 32))) != 0;
  }
  inline void _set_bit(int index) {
    _has_bits_[index / 32] |= (1u << (index % 32));
  }
  inline void _clear_bit(int index) {
    _has_bits_[index / 32] &= ~(1u << (index % 32));
  }
  
  void InitAsDefaultInstance();
  static msg_response* default_instance_;
};
// ===================================================================


// ===================================================================

// XSocketMsg

// required .xia.XSocketCallType type = 1;
inline bool XSocketMsg::has_type() const {
  return _has_bit(0);
}
inline void XSocketMsg::clear_type() {
  type_ = 0;
  _clear_bit(0);
}
inline xia::XSocketCallType XSocketMsg::type() const {
  return static_cast< xia::XSocketCallType >(type_);
}
inline void XSocketMsg::set_type(xia::XSocketCallType value) {
  GOOGLE_DCHECK(xia::XSocketCallType_IsValid(value));
  _set_bit(0);
  type_ = value;
}

// optional .xia.X_Socket_Msg x_socket = 2;
inline bool XSocketMsg::has_x_socket() const {
  return _has_bit(1);
}
inline void XSocketMsg::clear_x_socket() {
  if (x_socket_ != NULL) x_socket_->::xia::X_Socket_Msg::Clear();
  _clear_bit(1);
}
inline const ::xia::X_Socket_Msg& XSocketMsg::x_socket() const {
  return x_socket_ != NULL ? *x_socket_ : *default_instance_->x_socket_;
}
inline ::xia::X_Socket_Msg* XSocketMsg::mutable_x_socket() {
  _set_bit(1);
  if (x_socket_ == NULL) x_socket_ = new ::xia::X_Socket_Msg;
  return x_socket_;
}

// optional .xia.X_Bind_Msg x_bind = 3;
inline bool XSocketMsg::has_x_bind() const {
  return _has_bit(2);
}
inline void XSocketMsg::clear_x_bind() {
  if (x_bind_ != NULL) x_bind_->::xia::X_Bind_Msg::Clear();
  _clear_bit(2);
}
inline const ::xia::X_Bind_Msg& XSocketMsg::x_bind() const {
  return x_bind_ != NULL ? *x_bind_ : *default_instance_->x_bind_;
}
inline ::xia::X_Bind_Msg* XSocketMsg::mutable_x_bind() {
  _set_bit(2);
  if (x_bind_ == NULL) x_bind_ = new ::xia::X_Bind_Msg;
  return x_bind_;
}

// optional .xia.X_Close_Msg x_close = 4;
inline bool XSocketMsg::has_x_close() const {
  return _has_bit(3);
}
inline void XSocketMsg::clear_x_close() {
  if (x_close_ != NULL) x_close_->::xia::X_Close_Msg::Clear();
  _clear_bit(3);
}
inline const ::xia::X_Close_Msg& XSocketMsg::x_close() const {
  return x_close_ != NULL ? *x_close_ : *default_instance_->x_close_;
}
inline ::xia::X_Close_Msg* XSocketMsg::mutable_x_close() {
  _set_bit(3);
  if (x_close_ == NULL) x_close_ = new ::xia::X_Close_Msg;
  return x_close_;
}

// optional .xia.X_Connect_Msg x_connect = 5;
inline bool XSocketMsg::has_x_connect() const {
  return _has_bit(4);
}
inline void XSocketMsg::clear_x_connect() {
  if (x_connect_ != NULL) x_connect_->::xia::X_Connect_Msg::Clear();
  _clear_bit(4);
}
inline const ::xia::X_Connect_Msg& XSocketMsg::x_connect() const {
  return x_connect_ != NULL ? *x_connect_ : *default_instance_->x_connect_;
}
inline ::xia::X_Connect_Msg* XSocketMsg::mutable_x_connect() {
  _set_bit(4);
  if (x_connect_ == NULL) x_connect_ = new ::xia::X_Connect_Msg;
  return x_connect_;
}

// optional .xia.X_Accept_Msg x_accept = 6;
inline bool XSocketMsg::has_x_accept() const {
  return _has_bit(5);
}
inline void XSocketMsg::clear_x_accept() {
  if (x_accept_ != NULL) x_accept_->::xia::X_Accept_Msg::Clear();
  _clear_bit(5);
}
inline const ::xia::X_Accept_Msg& XSocketMsg::x_accept() const {
  return x_accept_ != NULL ? *x_accept_ : *default_instance_->x_accept_;
}
inline ::xia::X_Accept_Msg* XSocketMsg::mutable_x_accept() {
  _set_bit(5);
  if (x_accept_ == NULL) x_accept_ = new ::xia::X_Accept_Msg;
  return x_accept_;
}

// optional .xia.X_Putcid_Msg x_putcid = 7;
inline bool XSocketMsg::has_x_putcid() const {
  return _has_bit(6);
}
inline void XSocketMsg::clear_x_putcid() {
  if (x_putcid_ != NULL) x_putcid_->::xia::X_Putcid_Msg::Clear();
  _clear_bit(6);
}
inline const ::xia::X_Putcid_Msg& XSocketMsg::x_putcid() const {
  return x_putcid_ != NULL ? *x_putcid_ : *default_instance_->x_putcid_;
}
inline ::xia::X_Putcid_Msg* XSocketMsg::mutable_x_putcid() {
  _set_bit(6);
  if (x_putcid_ == NULL) x_putcid_ = new ::xia::X_Putcid_Msg;
  return x_putcid_;
}

// optional .xia.X_Getcid_Msg x_getcid = 8;
inline bool XSocketMsg::has_x_getcid() const {
  return _has_bit(7);
}
inline void XSocketMsg::clear_x_getcid() {
  if (x_getcid_ != NULL) x_getcid_->::xia::X_Getcid_Msg::Clear();
  _clear_bit(7);
}
inline const ::xia::X_Getcid_Msg& XSocketMsg::x_getcid() const {
  return x_getcid_ != NULL ? *x_getcid_ : *default_instance_->x_getcid_;
}
inline ::xia::X_Getcid_Msg* XSocketMsg::mutable_x_getcid() {
  _set_bit(7);
  if (x_getcid_ == NULL) x_getcid_ = new ::xia::X_Getcid_Msg;
  return x_getcid_;
}

// optional .xia.X_Sendto_Msg x_sendto = 9;
inline bool XSocketMsg::has_x_sendto() const {
  return _has_bit(8);
}
inline void XSocketMsg::clear_x_sendto() {
  if (x_sendto_ != NULL) x_sendto_->::xia::X_Sendto_Msg::Clear();
  _clear_bit(8);
}
inline const ::xia::X_Sendto_Msg& XSocketMsg::x_sendto() const {
  return x_sendto_ != NULL ? *x_sendto_ : *default_instance_->x_sendto_;
}
inline ::xia::X_Sendto_Msg* XSocketMsg::mutable_x_sendto() {
  _set_bit(8);
  if (x_sendto_ == NULL) x_sendto_ = new ::xia::X_Sendto_Msg;
  return x_sendto_;
}

// optional .xia.X_Send_Msg x_send = 10;
inline bool XSocketMsg::has_x_send() const {
  return _has_bit(9);
}
inline void XSocketMsg::clear_x_send() {
  if (x_send_ != NULL) x_send_->::xia::X_Send_Msg::Clear();
  _clear_bit(9);
}
inline const ::xia::X_Send_Msg& XSocketMsg::x_send() const {
  return x_send_ != NULL ? *x_send_ : *default_instance_->x_send_;
}
inline ::xia::X_Send_Msg* XSocketMsg::mutable_x_send() {
  _set_bit(9);
  if (x_send_ == NULL) x_send_ = new ::xia::X_Send_Msg;
  return x_send_;
}

// optional .xia.X_Recv_Msg x_recv = 11;
inline bool XSocketMsg::has_x_recv() const {
  return _has_bit(10);
}
inline void XSocketMsg::clear_x_recv() {
  if (x_recv_ != NULL) x_recv_->::xia::X_Recv_Msg::Clear();
  _clear_bit(10);
}
inline const ::xia::X_Recv_Msg& XSocketMsg::x_recv() const {
  return x_recv_ != NULL ? *x_recv_ : *default_instance_->x_recv_;
}
inline ::xia::X_Recv_Msg* XSocketMsg::mutable_x_recv() {
  _set_bit(10);
  if (x_recv_ == NULL) x_recv_ = new ::xia::X_Recv_Msg;
  return x_recv_;
}

// optional .xia.X_Recvfrom_Msg x_recvfrom = 12;
inline bool XSocketMsg::has_x_recvfrom() const {
  return _has_bit(11);
}
inline void XSocketMsg::clear_x_recvfrom() {
  if (x_recvfrom_ != NULL) x_recvfrom_->::xia::X_Recvfrom_Msg::Clear();
  _clear_bit(11);
}
inline const ::xia::X_Recvfrom_Msg& XSocketMsg::x_recvfrom() const {
  return x_recvfrom_ != NULL ? *x_recvfrom_ : *default_instance_->x_recvfrom_;
}
inline ::xia::X_Recvfrom_Msg* XSocketMsg::mutable_x_recvfrom() {
  _set_bit(11);
  if (x_recvfrom_ == NULL) x_recvfrom_ = new ::xia::X_Recvfrom_Msg;
  return x_recvfrom_;
}

// optional .xia.X_Getsocketidlist_Msg x_getsocketidlist = 13;
inline bool XSocketMsg::has_x_getsocketidlist() const {
  return _has_bit(12);
}
inline void XSocketMsg::clear_x_getsocketidlist() {
  if (x_getsocketidlist_ != NULL) x_getsocketidlist_->::xia::X_Getsocketidlist_Msg::Clear();
  _clear_bit(12);
}
inline const ::xia::X_Getsocketidlist_Msg& XSocketMsg::x_getsocketidlist() const {
  return x_getsocketidlist_ != NULL ? *x_getsocketidlist_ : *default_instance_->x_getsocketidlist_;
}
inline ::xia::X_Getsocketidlist_Msg* XSocketMsg::mutable_x_getsocketidlist() {
  _set_bit(12);
  if (x_getsocketidlist_ == NULL) x_getsocketidlist_ = new ::xia::X_Getsocketidlist_Msg;
  return x_getsocketidlist_;
}

// optional .xia.X_Getsocketinfo_Msg x_getsocketinfo = 14;
inline bool XSocketMsg::has_x_getsocketinfo() const {
  return _has_bit(13);
}
inline void XSocketMsg::clear_x_getsocketinfo() {
  if (x_getsocketinfo_ != NULL) x_getsocketinfo_->::xia::X_Getsocketinfo_Msg::Clear();
  _clear_bit(13);
}
inline const ::xia::X_Getsocketinfo_Msg& XSocketMsg::x_getsocketinfo() const {
  return x_getsocketinfo_ != NULL ? *x_getsocketinfo_ : *default_instance_->x_getsocketinfo_;
}
inline ::xia::X_Getsocketinfo_Msg* XSocketMsg::mutable_x_getsocketinfo() {
  _set_bit(13);
  if (x_getsocketinfo_ == NULL) x_getsocketinfo_ = new ::xia::X_Getsocketinfo_Msg;
  return x_getsocketinfo_;
}

// -------------------------------------------------------------------

// X_Socket_Msg

// required int32 type = 1;
inline bool X_Socket_Msg::has_type() const {
  return _has_bit(0);
}
inline void X_Socket_Msg::clear_type() {
  type_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 X_Socket_Msg::type() const {
  return type_;
}
inline void X_Socket_Msg::set_type(::google::protobuf::int32 value) {
  _set_bit(0);
  type_ = value;
}

// optional string temp = 2;
inline bool X_Socket_Msg::has_temp() const {
  return _has_bit(1);
}
inline void X_Socket_Msg::clear_temp() {
  if (temp_ != &_default_temp_) {
    temp_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& X_Socket_Msg::temp() const {
  return *temp_;
}
inline void X_Socket_Msg::set_temp(const ::std::string& value) {
  _set_bit(1);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Socket_Msg::set_temp(const char* value) {
  _set_bit(1);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Socket_Msg::set_temp(const char* value, size_t size) {
  _set_bit(1);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  temp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Socket_Msg::mutable_temp() {
  _set_bit(1);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  return temp_;
}

// -------------------------------------------------------------------

// X_Bind_Msg

// required string sdag = 1;
inline bool X_Bind_Msg::has_sdag() const {
  return _has_bit(0);
}
inline void X_Bind_Msg::clear_sdag() {
  if (sdag_ != &_default_sdag_) {
    sdag_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& X_Bind_Msg::sdag() const {
  return *sdag_;
}
inline void X_Bind_Msg::set_sdag(const ::std::string& value) {
  _set_bit(0);
  if (sdag_ == &_default_sdag_) {
    sdag_ = new ::std::string;
  }
  sdag_->assign(value);
}
inline void X_Bind_Msg::set_sdag(const char* value) {
  _set_bit(0);
  if (sdag_ == &_default_sdag_) {
    sdag_ = new ::std::string;
  }
  sdag_->assign(value);
}
inline void X_Bind_Msg::set_sdag(const char* value, size_t size) {
  _set_bit(0);
  if (sdag_ == &_default_sdag_) {
    sdag_ = new ::std::string;
  }
  sdag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Bind_Msg::mutable_sdag() {
  _set_bit(0);
  if (sdag_ == &_default_sdag_) {
    sdag_ = new ::std::string;
  }
  return sdag_;
}

// -------------------------------------------------------------------

// X_Close_Msg

// optional bytes payload = 1;
inline bool X_Close_Msg::has_payload() const {
  return _has_bit(0);
}
inline void X_Close_Msg::clear_payload() {
  if (payload_ != &_default_payload_) {
    payload_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& X_Close_Msg::payload() const {
  return *payload_;
}
inline void X_Close_Msg::set_payload(const ::std::string& value) {
  _set_bit(0);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Close_Msg::set_payload(const char* value) {
  _set_bit(0);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Close_Msg::set_payload(const void* value, size_t size) {
  _set_bit(0);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Close_Msg::mutable_payload() {
  _set_bit(0);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  return payload_;
}

// -------------------------------------------------------------------

// X_Connect_Msg

// required string ddag = 1;
inline bool X_Connect_Msg::has_ddag() const {
  return _has_bit(0);
}
inline void X_Connect_Msg::clear_ddag() {
  if (ddag_ != &_default_ddag_) {
    ddag_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& X_Connect_Msg::ddag() const {
  return *ddag_;
}
inline void X_Connect_Msg::set_ddag(const ::std::string& value) {
  _set_bit(0);
  if (ddag_ == &_default_ddag_) {
    ddag_ = new ::std::string;
  }
  ddag_->assign(value);
}
inline void X_Connect_Msg::set_ddag(const char* value) {
  _set_bit(0);
  if (ddag_ == &_default_ddag_) {
    ddag_ = new ::std::string;
  }
  ddag_->assign(value);
}
inline void X_Connect_Msg::set_ddag(const char* value, size_t size) {
  _set_bit(0);
  if (ddag_ == &_default_ddag_) {
    ddag_ = new ::std::string;
  }
  ddag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Connect_Msg::mutable_ddag() {
  _set_bit(0);
  if (ddag_ == &_default_ddag_) {
    ddag_ = new ::std::string;
  }
  return ddag_;
}

// -------------------------------------------------------------------

// X_Accept_Msg

// optional string temp = 1;
inline bool X_Accept_Msg::has_temp() const {
  return _has_bit(0);
}
inline void X_Accept_Msg::clear_temp() {
  if (temp_ != &_default_temp_) {
    temp_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& X_Accept_Msg::temp() const {
  return *temp_;
}
inline void X_Accept_Msg::set_temp(const ::std::string& value) {
  _set_bit(0);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Accept_Msg::set_temp(const char* value) {
  _set_bit(0);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Accept_Msg::set_temp(const char* value, size_t size) {
  _set_bit(0);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  temp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Accept_Msg::mutable_temp() {
  _set_bit(0);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  return temp_;
}

// -------------------------------------------------------------------

// X_Putcid_Msg

// required string sdag = 1;
inline bool X_Putcid_Msg::has_sdag() const {
  return _has_bit(0);
}
inline void X_Putcid_Msg::clear_sdag() {
  if (sdag_ != &_default_sdag_) {
    sdag_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& X_Putcid_Msg::sdag() const {
  return *sdag_;
}
inline void X_Putcid_Msg::set_sdag(const ::std::string& value) {
  _set_bit(0);
  if (sdag_ == &_default_sdag_) {
    sdag_ = new ::std::string;
  }
  sdag_->assign(value);
}
inline void X_Putcid_Msg::set_sdag(const char* value) {
  _set_bit(0);
  if (sdag_ == &_default_sdag_) {
    sdag_ = new ::std::string;
  }
  sdag_->assign(value);
}
inline void X_Putcid_Msg::set_sdag(const char* value, size_t size) {
  _set_bit(0);
  if (sdag_ == &_default_sdag_) {
    sdag_ = new ::std::string;
  }
  sdag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Putcid_Msg::mutable_sdag() {
  _set_bit(0);
  if (sdag_ == &_default_sdag_) {
    sdag_ = new ::std::string;
  }
  return sdag_;
}

// required bytes payload = 2;
inline bool X_Putcid_Msg::has_payload() const {
  return _has_bit(1);
}
inline void X_Putcid_Msg::clear_payload() {
  if (payload_ != &_default_payload_) {
    payload_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& X_Putcid_Msg::payload() const {
  return *payload_;
}
inline void X_Putcid_Msg::set_payload(const ::std::string& value) {
  _set_bit(1);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Putcid_Msg::set_payload(const char* value) {
  _set_bit(1);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Putcid_Msg::set_payload(const void* value, size_t size) {
  _set_bit(1);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Putcid_Msg::mutable_payload() {
  _set_bit(1);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  return payload_;
}

// -------------------------------------------------------------------

// X_Getcid_Msg

// optional string temp = 1;
inline bool X_Getcid_Msg::has_temp() const {
  return _has_bit(0);
}
inline void X_Getcid_Msg::clear_temp() {
  if (temp_ != &_default_temp_) {
    temp_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& X_Getcid_Msg::temp() const {
  return *temp_;
}
inline void X_Getcid_Msg::set_temp(const ::std::string& value) {
  _set_bit(0);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Getcid_Msg::set_temp(const char* value) {
  _set_bit(0);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Getcid_Msg::set_temp(const char* value, size_t size) {
  _set_bit(0);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  temp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Getcid_Msg::mutable_temp() {
  _set_bit(0);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  return temp_;
}

// -------------------------------------------------------------------

// X_Sendto_Msg

// required string ddag = 1;
inline bool X_Sendto_Msg::has_ddag() const {
  return _has_bit(0);
}
inline void X_Sendto_Msg::clear_ddag() {
  if (ddag_ != &_default_ddag_) {
    ddag_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& X_Sendto_Msg::ddag() const {
  return *ddag_;
}
inline void X_Sendto_Msg::set_ddag(const ::std::string& value) {
  _set_bit(0);
  if (ddag_ == &_default_ddag_) {
    ddag_ = new ::std::string;
  }
  ddag_->assign(value);
}
inline void X_Sendto_Msg::set_ddag(const char* value) {
  _set_bit(0);
  if (ddag_ == &_default_ddag_) {
    ddag_ = new ::std::string;
  }
  ddag_->assign(value);
}
inline void X_Sendto_Msg::set_ddag(const char* value, size_t size) {
  _set_bit(0);
  if (ddag_ == &_default_ddag_) {
    ddag_ = new ::std::string;
  }
  ddag_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Sendto_Msg::mutable_ddag() {
  _set_bit(0);
  if (ddag_ == &_default_ddag_) {
    ddag_ = new ::std::string;
  }
  return ddag_;
}

// required bytes payload = 2;
inline bool X_Sendto_Msg::has_payload() const {
  return _has_bit(1);
}
inline void X_Sendto_Msg::clear_payload() {
  if (payload_ != &_default_payload_) {
    payload_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& X_Sendto_Msg::payload() const {
  return *payload_;
}
inline void X_Sendto_Msg::set_payload(const ::std::string& value) {
  _set_bit(1);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Sendto_Msg::set_payload(const char* value) {
  _set_bit(1);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Sendto_Msg::set_payload(const void* value, size_t size) {
  _set_bit(1);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Sendto_Msg::mutable_payload() {
  _set_bit(1);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  return payload_;
}

// -------------------------------------------------------------------

// X_Send_Msg

// required bytes payload = 1;
inline bool X_Send_Msg::has_payload() const {
  return _has_bit(0);
}
inline void X_Send_Msg::clear_payload() {
  if (payload_ != &_default_payload_) {
    payload_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& X_Send_Msg::payload() const {
  return *payload_;
}
inline void X_Send_Msg::set_payload(const ::std::string& value) {
  _set_bit(0);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Send_Msg::set_payload(const char* value) {
  _set_bit(0);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void X_Send_Msg::set_payload(const void* value, size_t size) {
  _set_bit(0);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Send_Msg::mutable_payload() {
  _set_bit(0);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  return payload_;
}

// -------------------------------------------------------------------

// X_Recv_Msg

// optional string temp = 1;
inline bool X_Recv_Msg::has_temp() const {
  return _has_bit(0);
}
inline void X_Recv_Msg::clear_temp() {
  if (temp_ != &_default_temp_) {
    temp_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& X_Recv_Msg::temp() const {
  return *temp_;
}
inline void X_Recv_Msg::set_temp(const ::std::string& value) {
  _set_bit(0);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Recv_Msg::set_temp(const char* value) {
  _set_bit(0);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Recv_Msg::set_temp(const char* value, size_t size) {
  _set_bit(0);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  temp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Recv_Msg::mutable_temp() {
  _set_bit(0);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  return temp_;
}

// -------------------------------------------------------------------

// X_Recvfrom_Msg

// optional string temp = 1;
inline bool X_Recvfrom_Msg::has_temp() const {
  return _has_bit(0);
}
inline void X_Recvfrom_Msg::clear_temp() {
  if (temp_ != &_default_temp_) {
    temp_->clear();
  }
  _clear_bit(0);
}
inline const ::std::string& X_Recvfrom_Msg::temp() const {
  return *temp_;
}
inline void X_Recvfrom_Msg::set_temp(const ::std::string& value) {
  _set_bit(0);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Recvfrom_Msg::set_temp(const char* value) {
  _set_bit(0);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  temp_->assign(value);
}
inline void X_Recvfrom_Msg::set_temp(const char* value, size_t size) {
  _set_bit(0);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  temp_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Recvfrom_Msg::mutable_temp() {
  _set_bit(0);
  if (temp_ == &_default_temp_) {
    temp_ = new ::std::string;
  }
  return temp_;
}

// -------------------------------------------------------------------

// X_Getsocketidlist_Msg

// optional int32 size = 1;
inline bool X_Getsocketidlist_Msg::has_size() const {
  return _has_bit(0);
}
inline void X_Getsocketidlist_Msg::clear_size() {
  size_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 X_Getsocketidlist_Msg::size() const {
  return size_;
}
inline void X_Getsocketidlist_Msg::set_size(::google::protobuf::int32 value) {
  _set_bit(0);
  size_ = value;
}

// repeated int32 id = 2;
inline int X_Getsocketidlist_Msg::id_size() const {
  return id_.size();
}
inline void X_Getsocketidlist_Msg::clear_id() {
  id_.Clear();
}
inline ::google::protobuf::int32 X_Getsocketidlist_Msg::id(int index) const {
  return id_.Get(index);
}
inline void X_Getsocketidlist_Msg::set_id(int index, ::google::protobuf::int32 value) {
  id_.Set(index, value);
}
inline void X_Getsocketidlist_Msg::add_id(::google::protobuf::int32 value) {
  id_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
X_Getsocketidlist_Msg::id() const {
  return id_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
X_Getsocketidlist_Msg::mutable_id() {
  return &id_;
}

// -------------------------------------------------------------------

// X_Getsocketinfo_Msg

// required int32 id = 1;
inline bool X_Getsocketinfo_Msg::has_id() const {
  return _has_bit(0);
}
inline void X_Getsocketinfo_Msg::clear_id() {
  id_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 X_Getsocketinfo_Msg::id() const {
  return id_;
}
inline void X_Getsocketinfo_Msg::set_id(::google::protobuf::int32 value) {
  _set_bit(0);
  id_ = value;
}

// optional int32 port = 2;
inline bool X_Getsocketinfo_Msg::has_port() const {
  return _has_bit(1);
}
inline void X_Getsocketinfo_Msg::clear_port() {
  port_ = 0;
  _clear_bit(1);
}
inline ::google::protobuf::int32 X_Getsocketinfo_Msg::port() const {
  return port_;
}
inline void X_Getsocketinfo_Msg::set_port(::google::protobuf::int32 value) {
  _set_bit(1);
  port_ = value;
}

// optional bytes status = 3;
inline bool X_Getsocketinfo_Msg::has_status() const {
  return _has_bit(2);
}
inline void X_Getsocketinfo_Msg::clear_status() {
  if (status_ != &_default_status_) {
    status_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& X_Getsocketinfo_Msg::status() const {
  return *status_;
}
inline void X_Getsocketinfo_Msg::set_status(const ::std::string& value) {
  _set_bit(2);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void X_Getsocketinfo_Msg::set_status(const char* value) {
  _set_bit(2);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void X_Getsocketinfo_Msg::set_status(const void* value, size_t size) {
  _set_bit(2);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Getsocketinfo_Msg::mutable_status() {
  _set_bit(2);
  if (status_ == &_default_status_) {
    status_ = new ::std::string;
  }
  return status_;
}

// optional bytes xid = 4;
inline bool X_Getsocketinfo_Msg::has_xid() const {
  return _has_bit(3);
}
inline void X_Getsocketinfo_Msg::clear_xid() {
  if (xid_ != &_default_xid_) {
    xid_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& X_Getsocketinfo_Msg::xid() const {
  return *xid_;
}
inline void X_Getsocketinfo_Msg::set_xid(const ::std::string& value) {
  _set_bit(3);
  if (xid_ == &_default_xid_) {
    xid_ = new ::std::string;
  }
  xid_->assign(value);
}
inline void X_Getsocketinfo_Msg::set_xid(const char* value) {
  _set_bit(3);
  if (xid_ == &_default_xid_) {
    xid_ = new ::std::string;
  }
  xid_->assign(value);
}
inline void X_Getsocketinfo_Msg::set_xid(const void* value, size_t size) {
  _set_bit(3);
  if (xid_ == &_default_xid_) {
    xid_ = new ::std::string;
  }
  xid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Getsocketinfo_Msg::mutable_xid() {
  _set_bit(3);
  if (xid_ == &_default_xid_) {
    xid_ = new ::std::string;
  }
  return xid_;
}

// optional bytes xiapath_src = 5;
inline bool X_Getsocketinfo_Msg::has_xiapath_src() const {
  return _has_bit(4);
}
inline void X_Getsocketinfo_Msg::clear_xiapath_src() {
  if (xiapath_src_ != &_default_xiapath_src_) {
    xiapath_src_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& X_Getsocketinfo_Msg::xiapath_src() const {
  return *xiapath_src_;
}
inline void X_Getsocketinfo_Msg::set_xiapath_src(const ::std::string& value) {
  _set_bit(4);
  if (xiapath_src_ == &_default_xiapath_src_) {
    xiapath_src_ = new ::std::string;
  }
  xiapath_src_->assign(value);
}
inline void X_Getsocketinfo_Msg::set_xiapath_src(const char* value) {
  _set_bit(4);
  if (xiapath_src_ == &_default_xiapath_src_) {
    xiapath_src_ = new ::std::string;
  }
  xiapath_src_->assign(value);
}
inline void X_Getsocketinfo_Msg::set_xiapath_src(const void* value, size_t size) {
  _set_bit(4);
  if (xiapath_src_ == &_default_xiapath_src_) {
    xiapath_src_ = new ::std::string;
  }
  xiapath_src_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Getsocketinfo_Msg::mutable_xiapath_src() {
  _set_bit(4);
  if (xiapath_src_ == &_default_xiapath_src_) {
    xiapath_src_ = new ::std::string;
  }
  return xiapath_src_;
}

// optional bytes xiapath_dst = 6;
inline bool X_Getsocketinfo_Msg::has_xiapath_dst() const {
  return _has_bit(5);
}
inline void X_Getsocketinfo_Msg::clear_xiapath_dst() {
  if (xiapath_dst_ != &_default_xiapath_dst_) {
    xiapath_dst_->clear();
  }
  _clear_bit(5);
}
inline const ::std::string& X_Getsocketinfo_Msg::xiapath_dst() const {
  return *xiapath_dst_;
}
inline void X_Getsocketinfo_Msg::set_xiapath_dst(const ::std::string& value) {
  _set_bit(5);
  if (xiapath_dst_ == &_default_xiapath_dst_) {
    xiapath_dst_ = new ::std::string;
  }
  xiapath_dst_->assign(value);
}
inline void X_Getsocketinfo_Msg::set_xiapath_dst(const char* value) {
  _set_bit(5);
  if (xiapath_dst_ == &_default_xiapath_dst_) {
    xiapath_dst_ = new ::std::string;
  }
  xiapath_dst_->assign(value);
}
inline void X_Getsocketinfo_Msg::set_xiapath_dst(const void* value, size_t size) {
  _set_bit(5);
  if (xiapath_dst_ == &_default_xiapath_dst_) {
    xiapath_dst_ = new ::std::string;
  }
  xiapath_dst_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Getsocketinfo_Msg::mutable_xiapath_dst() {
  _set_bit(5);
  if (xiapath_dst_ == &_default_xiapath_dst_) {
    xiapath_dst_ = new ::std::string;
  }
  return xiapath_dst_;
}

// optional bytes protocol = 7;
inline bool X_Getsocketinfo_Msg::has_protocol() const {
  return _has_bit(6);
}
inline void X_Getsocketinfo_Msg::clear_protocol() {
  if (protocol_ != &_default_protocol_) {
    protocol_->clear();
  }
  _clear_bit(6);
}
inline const ::std::string& X_Getsocketinfo_Msg::protocol() const {
  return *protocol_;
}
inline void X_Getsocketinfo_Msg::set_protocol(const ::std::string& value) {
  _set_bit(6);
  if (protocol_ == &_default_protocol_) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void X_Getsocketinfo_Msg::set_protocol(const char* value) {
  _set_bit(6);
  if (protocol_ == &_default_protocol_) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(value);
}
inline void X_Getsocketinfo_Msg::set_protocol(const void* value, size_t size) {
  _set_bit(6);
  if (protocol_ == &_default_protocol_) {
    protocol_ = new ::std::string;
  }
  protocol_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* X_Getsocketinfo_Msg::mutable_protocol() {
  _set_bit(6);
  if (protocol_ == &_default_protocol_) {
    protocol_ = new ::std::string;
  }
  return protocol_;
}

// -------------------------------------------------------------------

// msg

// optional int32 appid = 1;
inline bool msg::has_appid() const {
  return _has_bit(0);
}
inline void msg::clear_appid() {
  appid_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 msg::appid() const {
  return appid_;
}
inline void msg::set_appid(::google::protobuf::int32 value) {
  _set_bit(0);
  appid_ = value;
}

// optional bytes xid = 2;
inline bool msg::has_xid() const {
  return _has_bit(1);
}
inline void msg::clear_xid() {
  if (xid_ != &_default_xid_) {
    xid_->clear();
  }
  _clear_bit(1);
}
inline const ::std::string& msg::xid() const {
  return *xid_;
}
inline void msg::set_xid(const ::std::string& value) {
  _set_bit(1);
  if (xid_ == &_default_xid_) {
    xid_ = new ::std::string;
  }
  xid_->assign(value);
}
inline void msg::set_xid(const char* value) {
  _set_bit(1);
  if (xid_ == &_default_xid_) {
    xid_ = new ::std::string;
  }
  xid_->assign(value);
}
inline void msg::set_xid(const void* value, size_t size) {
  _set_bit(1);
  if (xid_ == &_default_xid_) {
    xid_ = new ::std::string;
  }
  xid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* msg::mutable_xid() {
  _set_bit(1);
  if (xid_ == &_default_xid_) {
    xid_ = new ::std::string;
  }
  return xid_;
}

// optional string xiapath_src = 5;
inline bool msg::has_xiapath_src() const {
  return _has_bit(2);
}
inline void msg::clear_xiapath_src() {
  if (xiapath_src_ != &_default_xiapath_src_) {
    xiapath_src_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& msg::xiapath_src() const {
  return *xiapath_src_;
}
inline void msg::set_xiapath_src(const ::std::string& value) {
  _set_bit(2);
  if (xiapath_src_ == &_default_xiapath_src_) {
    xiapath_src_ = new ::std::string;
  }
  xiapath_src_->assign(value);
}
inline void msg::set_xiapath_src(const char* value) {
  _set_bit(2);
  if (xiapath_src_ == &_default_xiapath_src_) {
    xiapath_src_ = new ::std::string;
  }
  xiapath_src_->assign(value);
}
inline void msg::set_xiapath_src(const char* value, size_t size) {
  _set_bit(2);
  if (xiapath_src_ == &_default_xiapath_src_) {
    xiapath_src_ = new ::std::string;
  }
  xiapath_src_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* msg::mutable_xiapath_src() {
  _set_bit(2);
  if (xiapath_src_ == &_default_xiapath_src_) {
    xiapath_src_ = new ::std::string;
  }
  return xiapath_src_;
}

// optional string xiapath_dst = 6;
inline bool msg::has_xiapath_dst() const {
  return _has_bit(3);
}
inline void msg::clear_xiapath_dst() {
  if (xiapath_dst_ != &_default_xiapath_dst_) {
    xiapath_dst_->clear();
  }
  _clear_bit(3);
}
inline const ::std::string& msg::xiapath_dst() const {
  return *xiapath_dst_;
}
inline void msg::set_xiapath_dst(const ::std::string& value) {
  _set_bit(3);
  if (xiapath_dst_ == &_default_xiapath_dst_) {
    xiapath_dst_ = new ::std::string;
  }
  xiapath_dst_->assign(value);
}
inline void msg::set_xiapath_dst(const char* value) {
  _set_bit(3);
  if (xiapath_dst_ == &_default_xiapath_dst_) {
    xiapath_dst_ = new ::std::string;
  }
  xiapath_dst_->assign(value);
}
inline void msg::set_xiapath_dst(const char* value, size_t size) {
  _set_bit(3);
  if (xiapath_dst_ == &_default_xiapath_dst_) {
    xiapath_dst_ = new ::std::string;
  }
  xiapath_dst_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* msg::mutable_xiapath_dst() {
  _set_bit(3);
  if (xiapath_dst_ == &_default_xiapath_dst_) {
    xiapath_dst_ = new ::std::string;
  }
  return xiapath_dst_;
}

// optional bytes payload = 3;
inline bool msg::has_payload() const {
  return _has_bit(4);
}
inline void msg::clear_payload() {
  if (payload_ != &_default_payload_) {
    payload_->clear();
  }
  _clear_bit(4);
}
inline const ::std::string& msg::payload() const {
  return *payload_;
}
inline void msg::set_payload(const ::std::string& value) {
  _set_bit(4);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void msg::set_payload(const char* value) {
  _set_bit(4);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void msg::set_payload(const void* value, size_t size) {
  _set_bit(4);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* msg::mutable_payload() {
  _set_bit(4);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  return payload_;
}

// optional .xia.msg.MsgType type = 4;
inline bool msg::has_type() const {
  return _has_bit(5);
}
inline void msg::clear_type() {
  type_ = 0;
  _clear_bit(5);
}
inline ::xia::msg_MsgType msg::type() const {
  return static_cast< ::xia::msg_MsgType >(type_);
}
inline void msg::set_type(::xia::msg_MsgType value) {
  GOOGLE_DCHECK(::xia::msg_MsgType_IsValid(value));
  _set_bit(5);
  type_ = value;
}

// -------------------------------------------------------------------

// msg_response

// required int32 appid = 1;
inline bool msg_response::has_appid() const {
  return _has_bit(0);
}
inline void msg_response::clear_appid() {
  appid_ = 0;
  _clear_bit(0);
}
inline ::google::protobuf::int32 msg_response::appid() const {
  return appid_;
}
inline void msg_response::set_appid(::google::protobuf::int32 value) {
  _set_bit(0);
  appid_ = value;
}

// repeated bytes xid = 2;
inline int msg_response::xid_size() const {
  return xid_.size();
}
inline void msg_response::clear_xid() {
  xid_.Clear();
}
inline const ::std::string& msg_response::xid(int index) const {
  return xid_.Get(index);
}
inline ::std::string* msg_response::mutable_xid(int index) {
  return xid_.Mutable(index);
}
inline void msg_response::set_xid(int index, const ::std::string& value) {
  xid_.Mutable(index)->assign(value);
}
inline void msg_response::set_xid(int index, const char* value) {
  xid_.Mutable(index)->assign(value);
}
inline void msg_response::set_xid(int index, const void* value, size_t size) {
  xid_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* msg_response::add_xid() {
  return xid_.Add();
}
inline void msg_response::add_xid(const ::std::string& value) {
  xid_.Add()->assign(value);
}
inline void msg_response::add_xid(const char* value) {
  xid_.Add()->assign(value);
}
inline void msg_response::add_xid(const void* value, size_t size) {
  xid_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
msg_response::xid() const {
  return xid_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
msg_response::mutable_xid() {
  return &xid_;
}

// optional string payload = 3;
inline bool msg_response::has_payload() const {
  return _has_bit(2);
}
inline void msg_response::clear_payload() {
  if (payload_ != &_default_payload_) {
    payload_->clear();
  }
  _clear_bit(2);
}
inline const ::std::string& msg_response::payload() const {
  return *payload_;
}
inline void msg_response::set_payload(const ::std::string& value) {
  _set_bit(2);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void msg_response::set_payload(const char* value) {
  _set_bit(2);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(value);
}
inline void msg_response::set_payload(const char* value, size_t size) {
  _set_bit(2);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  payload_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* msg_response::mutable_payload() {
  _set_bit(2);
  if (payload_ == &_default_payload_) {
    payload_ = new ::std::string;
  }
  return payload_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace xia

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xia::msg_MsgType>() {
  return ::xia::msg_MsgType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< xia::XSocketCallType>() {
  return xia::XSocketCallType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_xia_2eproto__INCLUDED
